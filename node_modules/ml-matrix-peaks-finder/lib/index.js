'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var convolution = require('ml-matrix-convolution');
var DisjointSet = require('ml-disjoint-set');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var convolution__namespace = /*#__PURE__*/_interopNamespace(convolution);
var DisjointSet__default = /*#__PURE__*/_interopDefaultLegacy(DisjointSet);

const direction8X$1 = [-1, -1, 0, 1, -1, 0, 1, 1];
const direction8Y$1 = [0, -1, -1, -1, 1, 1, 1, 0];
const neighbours8$1 = [null, null, null, null, null, null, null, null];

const direction4X$1 = [-1, 0, 1, 0];
const direction4Y$1 = [0, -1, 0, 1];
const neighbours4$1 = [null, null, null, null];

function drainLabelling(data, mask, options = {}) {
  const { neighbours = 8, width, height } = options;

  let directionX;
  let directionY;
  let neighboursList;
  if (neighbours === 8) {
    directionX = direction8X$1;
    directionY = direction8Y$1;
    neighboursList = neighbours8$1;
  } else if (neighbours === 4) {
    directionX = direction4X$1;
    directionY = direction4Y$1;
    neighboursList = neighbours4$1;
  } else {
    throw new RangeError(`unsupported neighbours count: ${neighbours}`);
  }

  let sorted = new Array(height * width);
  for (let i = 0, index = 0; i < height; i++) {
    for (let j = 0; j < width; j++, index++) {
      sorted[index] = { value: data[index], row: i, col: j, mask: mask[index] };
    }
  }

  sorted.sort((a, b) => a.value - b.value);

  const size = mask.length;
  const labels = new Array(size);
  const pixels = new Int16Array(size);
  const linked = new DisjointSet__default['default']();

  for (let i = 0, currentLabel = 1; i < mask.length; i++) {
    let element = sorted[i];
    if (!element.mask) continue;

    let { row, col, value } = element;
    let index = col + row * width;
    let label = labels[index];
    if (!label) {
      labels[index] = linked.add(currentLabel++);
    }

    for (let k = 0; k < neighboursList.length; k++) {
      let ii = col + directionX[k];
      let jj = row + directionY[k];
      if (ii >= 0 && jj >= 0 && ii < width && jj < height) {
        let neighbor = labels[ii + jj * width];
        if (!neighbor) {
          let neighborValue = data[ii + jj * width];
          if (value < neighborValue) {
            labels[ii + jj * width] = labels[index];
          }
        }
      }
    }
  }

  for (let j = 0; j < height; j++) {
    for (let i = 0; i < width; i++) {
      let index = i + j * width;
      if (mask[index]) {
        pixels[index] = linked.find(labels[index]).value;
      }
    }
  }
  return pixels;
}

const direction4X = [-1, 0];
const direction4Y = [0, -1];
const neighbours4 = [null, null];

const direction8X = [-1, -1, 0, 1];
const direction8Y = [0, -1, -1, -1];
const neighbours8 = [null, null, null, null];

function floodFillLabelling(mask, width, height, options) {
  options = options || {};
  const neighbours = options.neighbours || 8;

  let directionX;
  let directionY;
  let neighboursList;
  if (neighbours === 8) {
    directionX = direction8X;
    directionY = direction8Y;
    neighboursList = neighbours8;
  } else if (neighbours === 4) {
    directionX = direction4X;
    directionY = direction4Y;
    neighboursList = neighbours4;
  } else {
    throw new RangeError(`unsupported neighbours count: ${neighbours}`);
  }

  const size = mask.length;
  const labels = new Array(size);
  const pixels = new Int16Array(size);
  const linked = new DisjointSet__default['default']();
  let index;
  let currentLabel = 1;
  for (let j = 0; j < height; j++) {
    for (let i = 0; i < width; i++) {
      // true means out of background
      let smallestNeighbor = null;
      index = i + j * width;
      if (mask[index]) {
        for (let k = 0; k < neighboursList.length; k++) {
          let ii = i + directionX[k];
          let jj = j + directionY[k];
          if (ii >= 0 && jj >= 0 && ii < width && jj < height) {
            let neighbor = labels[ii + jj * width];
            if (!neighbor) {
              neighboursList[k] = null;
            } else {
              neighboursList[k] = neighbor;
              if (
                !smallestNeighbor ||
                neighboursList[k].value < smallestNeighbor.value
              ) {
                smallestNeighbor = neighboursList[k];
              }
            }
          }
        }
        if (!smallestNeighbor) {
          labels[index] = linked.add(currentLabel++);
        } else {
          labels[index] = smallestNeighbor;
          for (let k = 0; k < neighboursList.length; k++) {
            if (neighboursList[k] && neighboursList[k] !== smallestNeighbor) {
              linked.union(smallestNeighbor, neighboursList[k]);
            }
          }
        }
      }
    }
  }
  for (let j = 0; j < height; j++) {
    for (let i = 0; i < width; i++) {
      index = i + j * width;
      if (mask[index]) {
        pixels[index] = linked.find(labels[index]).value;
      }
    }
  }
  return pixels;
}

const smallFilter = [
  [0, 0, 1, 2, 2, 2, 1, 0, 0],
  [0, 1, 4, 7, 7, 7, 4, 1, 0],
  [1, 4, 5, 3, 0, 3, 5, 4, 1],
  [2, 7, 3, -12, -23, -12, 3, 7, 2],
  [2, 7, 0, -23, -40, -23, 0, 7, 2],
  [2, 7, 3, -12, -23, -12, 3, 7, 2],
  [1, 4, 5, 3, 0, 3, 5, 4, 1],
  [0, 1, 3, 7, 7, 7, 3, 1, 0],
  [0, 0, 1, 2, 2, 2, 1, 0, 0],
];

/**
 * Detects all the 2D-peaks in the given spectrum based on center of mass logic.
 * @param {Array<Array>} input - matrix to get the local maxima
 * @param {Object} [options = {}] - options of the method.
 * @param {Array<Array>} [options.nStdDev = 3] - number of times of the standard deviations for the noise level.Float64Array
 * @param {Array<Array>} [options.kernel] - kernel to the convolution step.
 * @param {string} [options.labelling = 'drain'] - select the labelling algorithm to assign pixels.
 * @param {Array<Array>} [options.originalData] - original data useful when the original matrix has values and the input matrix has absolute ones
 * @param {Array<Array>} [options.filteredData] - convoluted data, if it is defined the convolution step is skipped
 */
function findPeaks2DRegion(input, options = {}) {
  let {
    nStdDev = 3,
    kernel = smallFilter,
    originalData = convolution__namespace.matrix2Array(input).data,
    filteredData,
    rows: nRows,
    cols: nCols,
    labelling = 'drain',
  } = options;

  let flatten = convolution__namespace.matrix2Array(input);
  let data = flatten.data;

  if (!nRows || !nCols) {
    nRows = flatten.rows;
    nCols = flatten.cols;
  }

  if (!nRows || !nCols) {
    throw new Error(`Invalid number of rows or columns ${nRows} ${nCols}`);
  }

  let cs = filteredData;
  if (!cs) cs = convolution__namespace.fft(data, kernel, options);

  let threshold = 0;
  for (let i = nCols * nRows - 2; i >= 0; i--) {
    threshold += Math.pow(cs[i] - cs[i + 1], 2);
  }
  threshold = (-Math.sqrt(threshold) * nStdDev) / nRows;

  let bitmask = new Uint16Array(nCols * nRows);
  for (let i = cs.length - 1; i >= 0; i--) {
    if (cs[i] < threshold) {
      bitmask[i] = 1;
    }
  }

  let pixels;
  switch (labelling.toLowerCase()) {
    case 'drain':
      pixels = drainLabelling(cs, bitmask, {
        neighbours: 8,
        width: nCols,
        height: nRows,
      });
      break;
    case 'floodfill':
      pixels = floodFillLabelling(bitmask, nCols, nRows, { neighbours: 8 });
      break;
    default:
      throw new Error(`labelling ${labelling} does not support`);
  }

  return extractPeaks(pixels, {
    data,
    nCols,
    originalData,
  });
}
/**
 Detects all the 2D-peaks in the given spectrum based on the Max logic.
 amc
 */
function findPeaks2DMax(input, options) {
  let {
    nStdDev = 3,
    kernel = smallFilter,
    originalData = convolution__namespace.matrix2Array(input).data,
    rows: nRows,
    cols: nCols,
    filteredData,
  } = options;

  let flatten = convolution__namespace.matrix2Array(input);
  let data = flatten.data;

  if (!nRows || !nCols) {
    nRows = flatten.rows;
    nCols = flatten.cols;
  }

  if (!nRows || !nCols) {
    throw new Error(`Invalid number of rows or columns ${nRows} ${nCols}`);
  }

  let cs = filteredData;
  if (!cs) cs = convolution__namespace.fft(data, kernel, options);

  let threshold = 0;
  for (let i = nCols * nRows - 2; i >= 0; i--) {
    threshold += Math.pow(cs[i] - cs[i + 1], 2);
  }
  threshold = (-Math.sqrt(threshold) * nStdDev) / nRows;

  let rowI, colI;
  let tmpIndex = 0;
  let peakListMax = [];
  for (let i = 0; i < cs.length; i++) {
    if (cs[i] < threshold) {
      //It is a peak?
      rowI = Math.floor(i / nCols);
      colI = i % nCols;
      //Verifies if this point is a peak;
      if (rowI > 0 && rowI + 1 < nRows && colI + 1 < nCols && colI > 0) {
        //It is the minimum in the same row
        if (cs[i] < cs[i + 1] && cs[i] < cs[i - 1]) {
          //It is the minimum in the previous row
          tmpIndex = (rowI - 1) * nCols + colI;
          if (
            cs[i] < cs[tmpIndex - 1] &&
            cs[i] < cs[tmpIndex] &&
            cs[i] < cs[tmpIndex + 1]
          ) {
            //It is the minimum in the next row
            tmpIndex = (rowI + 1) * nCols + colI;
            if (
              cs[i] < cs[tmpIndex - 1] &&
              cs[i] < cs[tmpIndex] &&
              cs[i] < cs[tmpIndex + 1]
            ) {
              peakListMax.push({ x: colI, y: rowI, z: originalData[i] });
            }
          }
        }
      }
    }
  }
  return peakListMax;
}

function extractPeaks(pixels, options) {
  const { data, nCols, originalData } = options;
  //How many different groups we have?
  let labels = {};
  let row, col, tmp;
  for (let i = 0; i < pixels.length; i++) {
    if (pixels[i] !== 0) {
      col = i % nCols;
      row = (i - col) / nCols;
      if (labels[pixels[i]]) {
        tmp = labels[pixels[i]];
        tmp.x += col * data[i];
        tmp.y += row * data[i];
        tmp.z += originalData[i];
        if (col < tmp.minX) tmp.minX = col;
        if (col > tmp.maxX) tmp.maxX = col;
        if (row < tmp.minY) tmp.minY = row;
        if (row > tmp.maxY) tmp.maxY = row;
      } else {
        labels[pixels[i]] = {
          x: col * data[i],
          y: row * data[i],
          z: originalData[i],
          minX: col,
          maxX: col,
          minY: row,
          maxY: row,
        };
      }
    }
  }
  let keys = Object.keys(labels);
  let peakList = new Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    peakList[i] = labels[keys[i]];
    let zValue = Math.abs(peakList[i].z);
    peakList[i].x /= zValue;
    peakList[i].y /= zValue;
  }

  return peakList;
}

exports.findPeaks2DMax = findPeaks2DMax;
exports.findPeaks2DRegion = findPeaks2DRegion;
