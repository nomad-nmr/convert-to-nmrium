"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAssignments = void 0;
const ml_tree_set_1 = __importDefault(require("ml-tree-set"));
const createMapPossibleAssignments_1 = require("./createMapPossibleAssignments");
const exploreTreeRec_1 = require("./exploreTreeRec");
const comparator = (a, b) => {
    return b.score - a.score;
};
async function buildAssignments(props) {
    const { restrictionByCS = {}, useIntegrationRestriction, timeout, minScore, nbAllowedUnAssigned, maxSolutions, targets, joinedSignals, } = props;
    const { tolerance = 1, useChemicalShiftScore = false, chemicalShiftRestriction = true, } = restrictionByCS;
    let date = new Date();
    let timeStart = date.getTime();
    let store = {
        solutions: new ml_tree_set_1.default(comparator),
        nSolutions: 0,
    };
    let nSources = joinedSignals.length;
    const predictions = {};
    for (let prediction of joinedSignals) {
        const diaID = prediction.diaIDs[0];
        const index = prediction.atoms[0];
        predictions[diaID] = {
            ...prediction,
            diaIDIndex: index,
            allHydrogens: prediction.nbAtoms,
        };
    }
    const possibleAssignmentMap = (0, createMapPossibleAssignments_1.createMapPossibleAssignments)({
        restrictionByCS: {
            tolerance,
            useChemicalShiftScore,
            chemicalShiftRestriction,
        },
        useIntegrationRestriction,
        predictions,
        targets,
    });
    const diaIDPeerPossibleAssignment = Object.keys(possibleAssignmentMap);
    let partial = fillPartial(nSources);
    store = {
        solutions: new ml_tree_set_1.default(comparator),
        nSolutions: 0,
    };
    (0, exploreTreeRec_1.exploreTreeRec)({
        nSources,
        restrictionByCS: {
            tolerance,
            useChemicalShiftScore,
            chemicalShiftRestriction,
        },
        timeout,
        timeStart,
        targets,
        predictions,
        maxSolutions,
        lowerBoundScore: minScore,
        nbAllowedUnAssigned,
        possibleAssignmentMap,
        diaIDPeerPossibleAssignment,
        useIntegrationRestriction,
    }, 0, partial, store);
    const assignments = [];
    for (const solution of store.solutions.elements) {
        const { assignment, score } = solution;
        const currentAssignment = JSON.parse(JSON.stringify(targets));
        for (let i = 0; i < assignment.length; i++) {
            let range = currentAssignment[assignment[i]];
            if (!range.diaIDs)
                range.diaIDs = [];
            if (assignment[i])
                range.diaIDs.push(diaIDPeerPossibleAssignment[i]);
        }
        assignments.push({
            score,
            assignment: Object.values(currentAssignment),
        });
    }
    return assignments;
}
exports.buildAssignments = buildAssignments;
function fillPartial(nSources, value = null) {
    const partial = new Array(nSources);
    for (let i = 0; i < nSources; i++) {
        partial[i] = value;
    }
    return partial;
}
//# sourceMappingURL=buildAssignments.js.map