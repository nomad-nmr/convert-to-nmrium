"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.predictCarbon = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const signalsToRanges_1 = require("../signals/signalsToRanges");
const fetchPrediction_1 = require("./utils/fetchPrediction");
const flatGroupedDiaIDs_1 = require("./utils/flatGroupedDiaIDs");
const getFilteredIDiaIDs_1 = require("./utils/getFilteredIDiaIDs");
const queryByHOSE_1 = require("./utils/queryByHOSE");
const cache = {};
async function loadDB(url = 'https://www.lactame.com/lib/nmr-processing-data/20210711/carbon.js') {
    if (cache[url]) {
        return cache[url];
    }
    const response = await (0, cross_fetch_1.default)(url);
    const database = await response.json();
    cache[url] = database;
    return database;
}
function checkFromPrediction(signal) {
    if (!signal.atoms)
        throw new Error('There is not atoms');
    if (!signal.diaIDs)
        throw new Error('There is not diaIDs');
    if (!signal.nbAtoms)
        throw new Error('There is not nbAtoms');
}
/**
 * Make a query to a hose code based database to predict carbon chemical shift
 * @returns {Promise<object>} - object with molfile, diaIDs, signals, joined signals by diaIDs and ranges.
 */
async function predictCarbon(molecule, options = {}) {
    let { url, database, webserviceURL } = options;
    if (webserviceURL) {
        return (0, fetchPrediction_1.fetchPrediction)(molecule, { webserviceURL });
    }
    if (!database)
        database = await loadDB(url);
    if (!database) {
        throw new Error('There is not a database');
    }
    const maxLevel = database.length - 1;
    let { maxSphereSize = maxLevel } = options;
    if (maxSphereSize > maxLevel)
        maxSphereSize = maxLevel;
    const { groupedDiaIDs, carbonDiaIDs, molfile } = (0, getFilteredIDiaIDs_1.getFilteredIDiaIDs)(molecule, {
        maxSphereSize,
    });
    let predictions = (0, queryByHOSE_1.queryByHose)(carbonDiaIDs, database, {
        maxSphereSize,
    });
    const signals = formatSignals(predictions);
    const joinedSignals = joinSignalByDiaID(signals);
    return {
        molfile,
        nucleus: '13C',
        diaIDs: (0, flatGroupedDiaIDs_1.flatGroupedDiaIDs)(groupedDiaIDs),
        joinedSignals,
        signals,
        ranges: (0, signalsToRanges_1.signalsToRanges)(joinedSignals),
        molecule,
    };
}
exports.predictCarbon = predictCarbon;
function formatSignals(predictions) {
    let signals = [];
    for (const prediction of predictions) {
        const { atoms, nbAtoms, delta, diaIDs, statistic } = prediction;
        const signal = {
            delta: delta || NaN,
            atoms,
            diaIDs: diaIDs,
            multiplicity: 's',
            nbAtoms,
            statistic,
            js: [],
        };
        signals.push(signal);
    }
    return signals;
}
function joinSignalByDiaID(signals) {
    let joinedSignals = {};
    for (let signal of signals) {
        checkFromPrediction(signal);
        let diaID = signal.diaIDs[0];
        if (!joinedSignals[diaID]) {
            joinedSignals[diaID] = JSON.parse(JSON.stringify(signal));
        }
        else {
            joinedSignals[diaID].nbAtoms += signal.nbAtoms;
            joinedSignals[diaID].atoms.push(...signal.atoms);
        }
    }
    return Object.values(joinedSignals);
}
//# sourceMappingURL=predictCarbon.js.map