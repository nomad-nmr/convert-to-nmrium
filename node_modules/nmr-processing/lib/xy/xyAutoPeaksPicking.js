"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyAutoPeaksPicking = void 0;
const ml_gsd_1 = require("ml-gsd");
const ml_spectra_processing_1 = require("ml-spectra-processing");
function xyAutoPeaksPicking(data, options = {}) {
    const { from, to, noiseLevel, thresholdFactor = 3, minMaxRatio = 0.05, broadRatio = 0.00025, useSanPlot = false, smoothY = true, optimize = false, factorLimits = 4, realTopDetection = true, shape = { kind: 'gaussian' }, optimization = { kind: 'lm' }, broadWidth = 0.25, sgOptions = {}, lookNegative = false, } = options;
    const { windowSize = 9, polynomial = 3 } = sgOptions;
    if (from !== undefined && to !== undefined) {
        data = (0, ml_spectra_processing_1.xyExtract)(data, { zones: [{ from, to }] });
    }
    if (data.x.length < windowSize)
        return [];
    const cutOff = getCutOff(data.y, { noiseLevel, useSanPlot, thresholdFactor });
    let getPeakOptions = {
        shape,
        broadWidth,
        optimize,
        factorLimits,
        maxCriteria: true,
        sgOptions: { windowSize, polynomial },
        minMaxRatio,
        broadRatio,
        noiseLevel: cutOff.positive,
        smoothY,
        optimization,
        realTopDetection,
    };
    let peaks = getPeakList(data, getPeakOptions);
    if (lookNegative) {
        getPeakOptions.noiseLevel = cutOff.negative;
        getPeakOptions.maxCriteria = false;
        peaks.push(...getPeakList(data, getPeakOptions));
    }
    return peaks;
}
exports.xyAutoPeaksPicking = xyAutoPeaksPicking;
function getPeakList(data, options) {
    const { shape, broadWidth, optimize, maxCriteria, factorLimits, sgOptions, minMaxRatio, broadRatio, noiseLevel, smoothY, optimization, realTopDetection, } = options;
    let peakList = (0, ml_gsd_1.gsd)(data, {
        sgOptions,
        maxCriteria,
        minMaxRatio,
        noiseLevel,
        smoothY,
        realTopDetection,
    });
    if (broadWidth) {
        peakList = (0, ml_gsd_1.joinBroadPeaks)(peakList, {
            broadRatio,
            broadWidth,
            shape,
            optimization,
        });
    }
    if (optimize) {
        return (0, ml_gsd_1.optimizePeaks)(data, peakList, {
            shape,
            factorLimits,
            optimization,
        });
    }
    return (0, ml_gsd_1.appendShapeAndFWHM)(peakList, { shape });
}
function getCutOff(data, options) {
    const { noiseLevel, useSanPlot, thresholdFactor } = options;
    const formatResult = (noiseLevel) => typeof noiseLevel === 'number'
        ? { positive: noiseLevel, negative: -noiseLevel }
        : noiseLevel;
    if (noiseLevel) {
        return formatResult(noiseLevel);
    }
    else {
        return useSanPlot
            ? (0, ml_spectra_processing_1.xNoiseSanPlot)(data, { factorStd: thresholdFactor })
            : formatResult((0, ml_spectra_processing_1.xAbsoluteMedian)(data) * thresholdFactor);
    }
}
//# sourceMappingURL=xyAutoPeaksPicking.js.map