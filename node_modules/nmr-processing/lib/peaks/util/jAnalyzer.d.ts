import type { MakeMandatory } from '../../utilities/MakeMandatory';
import type { NMRPeak1D } from '../NMRPeak1D';
export interface JAxisKeys {
    [key: string]: string;
    jAxis: string;
    intensity: string;
}
interface IntergralData {
    value: number;
    from: number;
    to: number;
}
export declare type Peak1DIntern = Omit<NMRPeak1D, 'y' | 'shape' | 'fwhm'> & {
    intensity: number;
};
export interface SignalIntern {
    delta: number;
    nbPeaks: number;
    startX: number;
    stopX: number;
    asymmetric?: boolean;
    symRank?: number;
    mask?: boolean[];
    mask2?: boolean[];
    maskPattern?: boolean[];
    nmrJs?: Array<{
        coupling: number;
        multiplicity: string;
    }>;
    multiplicity?: string;
    pattern?: string;
    observe: number;
    nucleus: string;
    kind: string;
    integralData: IntergralData;
    peaks: Peak1DIntern[];
    peaksComp?: Peak1DIntern[];
}
declare type SignalInternMandatory = MakeMandatory<SignalIntern, 'symRank' | 'mask' | 'peaksComp'>;
export interface OpitonsCompilePatter {
    jAxisKey?: JAxisKeys;
}
declare const _default: {
    /**
     * The compilation process implements at the first stage a normalization procedure described by Golotvin et al.
     * embedding in peak-component-counting method described by Hoyes et al.
     * @param {object} signal
     * @private
     */
    compilePattern: (inputSignal: SignalIntern, options?: OpitonsCompilePatter) => SignalInternMandatory;
};
export default _default;
