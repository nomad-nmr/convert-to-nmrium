"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyzAutoZonesPicking = void 0;
const ml_matrix_1 = require("ml-matrix");
const convolution = __importStar(require("ml-matrix-convolution"));
const matrixPeakFinders = __importStar(require("ml-matrix-peaks-finder"));
const ml_simple_clustering_1 = __importDefault(require("ml-simple-clustering"));
const determineRealTop_1 = require("../peaks/util/determineRealTop");
const getKernel_1 = require("../peaks/util/getKernel");
const PeakOptimizer = __importStar(require("../peaks/util/peakOptimizer"));
const smallFilter = [
    [0, 0, 1, 2, 2, 2, 1, 0, 0],
    [0, 1, 4, 7, 7, 7, 4, 1, 0],
    [1, 4, 5, 3, 0, 3, 5, 4, 1],
    [2, 7, 3, -12, -23, -12, 3, 7, 2],
    [2, 7, 0, -23, -40, -23, 0, 7, 2],
    [2, 7, 3, -12, -23, -12, 3, 7, 2],
    [1, 4, 5, 3, 0, 3, 5, 4, 1],
    [0, 1, 3, 7, 7, 7, 3, 1, 0],
    [0, 0, 1, 2, 2, 2, 1, 0, 0],
];
function xyzAutoZonesPicking(spectraData, options) {
    let { sizeToPad = 14, realTopDetection = true, thresholdFactor = 0.5, nuclei = ['1H', '1H'], observedFrequencies, enhanceSymmetry = false, clean = true, maxPercentCutOff = 0.03, tolerances = [24, 24], convolutionByFFT = true, kernel: kernelOptions, } = options;
    if (!Array.isArray(observedFrequencies) &&
        !ArrayBuffer.isView(observedFrequencies)) {
        throw new Error('observedFrequencies is mandatory');
    }
    thresholdFactor = thresholdFactor === 0 ? 1 : Math.abs(thresholdFactor);
    let nbPoints = spectraData.z[0].length;
    let nbSubSpectra = spectraData.z.length;
    if (nbSubSpectra < sizeToPad) {
        spectraData = padData(spectraData, { width: sizeToPad });
        nbPoints = spectraData.z[0].length;
        nbSubSpectra = spectraData.z.length;
    }
    let absoluteData = new Float64Array(nbPoints * nbSubSpectra);
    let originalData = new Float64Array(nbPoints * nbSubSpectra);
    for (let iSubSpectra = 0; iSubSpectra < nbSubSpectra; iSubSpectra++) {
        let spectrum = spectraData.z[iSubSpectra];
        for (let iCol = 0; iCol < nbPoints; iCol++) {
            let index = iSubSpectra * nbPoints + iCol;
            absoluteData[index] = Math.abs(spectrum[iCol]);
            originalData[index] = spectrum[iCol]; //@todo pensar si se puede evitar originalData
        }
    }
    const kernel = kernelOptions ? (0, getKernel_1.getKernel)(kernelOptions) : smallFilter;
    let convolutedSpectrum = convolutionByFFT
        ? convolution.fft(absoluteData, kernel, {
            rows: nbSubSpectra,
            cols: nbPoints,
        })
        : convolution.direct(absoluteData, kernel, {
            rows: nbSubSpectra,
            cols: nbPoints,
        });
    let peaksMC1 = matrixPeakFinders.findPeaks2DRegion(absoluteData, {
        originalData,
        filteredData: convolutedSpectrum,
        rows: nbSubSpectra,
        cols: nbPoints,
        nStdDev: thresholdFactor,
    });
    if (clean) {
        // Remove peaks with less than x% of the intensity of the highest peak
        peaksMC1 = PeakOptimizer.clean(peaksMC1, maxPercentCutOff);
    }
    let signals = createSignals2D(peaksMC1, {
        nRows: nbSubSpectra,
        nCols: nbPoints,
        minX: spectraData.minX,
        maxX: spectraData.maxX,
        minY: spectraData.minY,
        maxY: spectraData.maxY,
        absoluteData,
        originalData,
        tolerances,
        nuclei,
        observedFrequencies,
        realTopDetection,
    });
    if (enhanceSymmetry) {
        signals = PeakOptimizer.enhanceSymmetry(signals);
    }
    return formatZones(signals);
}
exports.xyzAutoZonesPicking = xyzAutoZonesPicking;
function formatZones(signals) {
    let zones = [];
    for (const signal of signals) {
        let minMax1 = [Number.MAX_VALUE, 0];
        let minMax2 = [Number.MAX_VALUE, 0];
        for (const peak of signal.peaks || []) {
            if (peak.minX < minMax1[0]) {
                minMax1[0] = peak.minX;
            }
            if (peak.maxX > minMax1[1]) {
                minMax1[1] = peak.maxX;
            }
            if (peak.minY < minMax2[0]) {
                minMax2[0] = peak.minY;
            }
            if (peak.maxY > minMax2[1]) {
                minMax2[1] = peak.maxY;
            }
        }
        zones.push({
            x: {
                from: minMax1[0],
                to: minMax1[1],
            },
            y: {
                from: minMax2[0],
                to: minMax2[1],
            },
            signals: [signal],
        });
    }
    return zones;
}
const createSignals2D = (peaks, options) => {
    let { nCols, nRows, absoluteData, originalData, observedFrequencies, tolerances, nuclei, realTopDetection, minY, maxY, minX, maxX, } = options;
    let [nucleusX, nucleusY] = nuclei;
    let [toleranceX, toleranceY] = tolerances;
    let [observeFrequencyX, observeFrequencyY] = observedFrequencies;
    let dy = (maxY - minY) / (nRows - 1);
    let dx = (maxX - minX) / (nCols - 1);
    if (realTopDetection) {
        peaks = (0, determineRealTop_1.determineRealTop)(peaks, {
            nCols,
            absoluteData,
            originalData,
            minX,
            maxX,
            minY,
            maxY,
        });
    }
    for (let i = peaks.length - 1; i >= 0; i--) {
        let { x, y } = peaks[i];
        peaks[i].x = minX + dx * x;
        peaks[i].y = minY + dy * y;
        peaks[i].minX = minX + dx * peaks[i].minX;
        peaks[i].minY = minY + dy * peaks[i].minY;
        peaks[i].maxX = minX + dx * peaks[i].maxX;
        peaks[i].maxY = minY + dy * peaks[i].maxY;
        // Still having problems to correctly detect peaks on those areas. So I'm removing everything there.
    }
    // The connectivity matrix is an square and symmetric matrix, so we'll only store the upper diagonal in an
    // array like form
    let connectivity = [];
    for (let i = 0; i < peaks.length; i++) {
        for (let j = i; j < peaks.length; j++) {
            if (Math.abs(peaks[i].x - peaks[j].x) * observeFrequencyX < toleranceX &&
                Math.abs(peaks[i].y - peaks[j].y) * observeFrequencyY < toleranceY) {
                // 24*24Hz We cannot distinguish peaks with less than 20 Hz of separation
                connectivity.push(1);
            }
            else {
                connectivity.push(0);
            }
        }
    }
    let clusters = (0, ml_simple_clustering_1.default)(connectivity);
    let signals = [];
    if (clusters) {
        for (const cluster of clusters) {
            let signal = {
                x: {
                    delta: 0,
                    nucleus: nucleusX,
                    resolution: dx,
                },
                y: {
                    delta: 0,
                    nucleus: nucleusY,
                    resolution: dy,
                },
            };
            let peaks2D = [];
            let sumZ = 0;
            for (let jPeak = 0; jPeak < cluster.length; jPeak++) {
                if (cluster[jPeak] === 1) {
                    peaks2D.push(peaks[jPeak]);
                    signal.x.delta += peaks[jPeak].x * peaks[jPeak].z;
                    signal.y.delta += peaks[jPeak].y * peaks[jPeak].z;
                    sumZ += peaks[jPeak].z;
                }
            }
            signal.x.delta /= sumZ;
            signal.y.delta /= sumZ;
            signal.peaks = peaks2D;
            signals.push(signal);
        }
    }
    return signals;
};
const padData = (spectraData, options) => {
    let { minX, maxX, minY, maxY } = spectraData;
    const width = options.width;
    let nbPoints = spectraData.z[0].length;
    let nbSubSpectra = spectraData.z.length;
    let yInterval = (maxY - minY) / (nbSubSpectra - 1);
    let xInterval = (maxX - minX) / (nbPoints - 1);
    let yDiff = width - nbSubSpectra;
    let xDiff = Math.max(width - nbPoints, 0);
    if (xDiff % 2)
        xDiff++;
    if (yDiff % 2)
        yDiff++;
    let xOffset = xDiff / 2;
    let yOffset = yDiff / 2;
    let newMatrix = ml_matrix_1.Matrix.zeros(nbSubSpectra + yDiff, nbPoints + xDiff);
    for (let i = 0; i < nbSubSpectra; i++) {
        for (let j = 0; j < nbPoints; j++) {
            newMatrix.set(i + yOffset, j + xOffset, spectraData.z[i][j]);
        }
    }
    return {
        z: newMatrix.to2DArray(),
        minX: minX - xOffset * xInterval,
        maxX: maxX + xOffset * xInterval,
        minY: minY - yOffset * yInterval,
        maxY: maxY + yOffset * yInterval,
    };
};
//# sourceMappingURL=xyzAutoZonesPicking.js.map