import { gsd, optimizePeaks, joinBroadPeaks, appendShapeAndFWHM } from 'ml-gsd';
import { xyExtract, xNoiseSanPlot, xAbsoluteMedian, } from 'ml-spectra-processing';
export function xyAutoPeaksPicking(data, options = {}) {
    const { from, to, noiseLevel, thresholdFactor = 3, minMaxRatio = 0.05, broadRatio = 0.00025, useSanPlot = false, smoothY = true, optimize = false, factorLimits = 4, realTopDetection = true, shape = { kind: 'gaussian' }, optimization = { kind: 'lm' }, broadWidth = 0.25, sgOptions = {}, lookNegative = false, } = options;
    const { windowSize = 9, polynomial = 3 } = sgOptions;
    if (from !== undefined && to !== undefined) {
        data = xyExtract(data, { zones: [{ from, to }] });
    }
    if (data.x.length < windowSize)
        return [];
    const cutOff = getCutOff(data.y, { noiseLevel, useSanPlot, thresholdFactor });
    let getPeakOptions = {
        shape,
        broadWidth,
        optimize,
        factorLimits,
        maxCriteria: true,
        sgOptions: { windowSize, polynomial },
        minMaxRatio,
        broadRatio,
        noiseLevel: cutOff.positive,
        smoothY,
        optimization,
        realTopDetection,
    };
    let peaks = getPeakList(data, getPeakOptions);
    if (lookNegative) {
        getPeakOptions.noiseLevel = cutOff.negative;
        getPeakOptions.maxCriteria = false;
        peaks.push(...getPeakList(data, getPeakOptions));
    }
    return peaks;
}
function getPeakList(data, options) {
    const { shape, broadWidth, optimize, maxCriteria, factorLimits, sgOptions, minMaxRatio, broadRatio, noiseLevel, smoothY, optimization, realTopDetection, } = options;
    let peakList = gsd(data, {
        sgOptions,
        maxCriteria,
        minMaxRatio,
        noiseLevel,
        smoothY,
        realTopDetection,
    });
    if (broadWidth) {
        peakList = joinBroadPeaks(peakList, {
            broadRatio,
            broadWidth,
            shape,
            optimization,
        });
    }
    if (optimize) {
        return optimizePeaks(data, peakList, {
            shape,
            factorLimits,
            optimization,
        });
    }
    return appendShapeAndFWHM(peakList, { shape });
}
function getCutOff(data, options) {
    const { noiseLevel, useSanPlot, thresholdFactor } = options;
    const formatResult = (noiseLevel) => typeof noiseLevel === 'number'
        ? { positive: noiseLevel, negative: -noiseLevel }
        : noiseLevel;
    if (noiseLevel) {
        return formatResult(noiseLevel);
    }
    else {
        return useSanPlot
            ? xNoiseSanPlot(data, { factorStd: thresholdFactor })
            : formatResult(xAbsoluteMedian(data) * thresholdFactor);
    }
}
//# sourceMappingURL=xyAutoPeaksPicking.js.map