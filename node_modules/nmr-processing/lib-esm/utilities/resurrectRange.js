import { rangeFromSignal } from './rangeFromSignal';
import { splitParenthesis } from './splitParenthesis';
import { splitPatterns } from './splitPatterns';
export function resurrectRange(part, options = {}) {
    const { nucleus = '1h', frequency = 400 } = options;
    const split = splitParenthesis(part);
    if (!split.before)
        return;
    const beforeMatch = /.*?(?<from>-?[0-9.]+)-?(?<to>-?[0-9.]*).*/.exec(split.before);
    if (!beforeMatch || !beforeMatch.groups)
        return;
    const isARange = beforeMatch.groups.to !== '';
    const from = Number(beforeMatch.groups.from);
    const to = isARange ? Number(beforeMatch.groups.to) : from;
    const insideParts = split.inside.split(/ *, */);
    let signal = { delta: NaN, js: [] };
    let range = { from, to, signals: [signal] };
    const integrationParts = insideParts.filter((part) => part.match(/^[0-9]+H$/));
    if (integrationParts.length === 1) {
        range.integration = Number(integrationParts[0].replace('H', ''));
    }
    const multiplicityParts = insideParts.filter((part) => part.match(/^[a-zA-Z]+$/));
    if (multiplicityParts.length === 1) {
        const multiplicity = multiplicityParts[0];
        if (multiplicity === 'm') {
            if (isARange) {
                // a real range
                signal.delta = (from + to) / 2;
                signal.multiplicity = multiplicity;
            }
            else {
                // a complex signal
                signal.delta = from;
                signal.multiplicity = multiplicity;
            }
        }
        else {
            // looks like a real multiplicity, s, d, dd, etc..
            if (!isARange) {
                // a complex signal
                signal.delta = from;
                signal.multiplicity = multiplicity;
            }
        }
    }
    const jCouplings = insideParts
        .filter((part) => part.match(/(Hz|J|^[0-9.]+$)/))
        .map((jCoupling) => Number(jCoupling.replace(/[^0-9.]/g, '')));
    const multiplicities = splitPatterns(signal.multiplicity || '');
    if (multiplicities.length === jCouplings.length) {
        for (let i = 0; i < multiplicities.length; i++) {
            if (!signal.js) {
                throw new Error('signal has not js');
            }
            signal.js.push({
                coupling: jCouplings[i],
                multiplicity: multiplicities[i],
            });
        }
    }
    if (range.from === range.to) {
        range = { ...range, ...rangeFromSignal(signal, { nucleus, frequency }) };
    }
    return range;
}
//# sourceMappingURL=resurrectRange.js.map