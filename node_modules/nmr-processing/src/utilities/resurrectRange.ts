import type { NMRSignal1D } from '../signals/NMRSignal1D';
import type { NMRRange } from '../xy/NMRRange';

import { rangeFromSignal } from './rangeFromSignal';
import { splitParenthesis } from './splitParenthesis';
import { splitPatterns } from './splitPatterns';

export function resurrectRange(part: string, options: any = {}) {
  const { nucleus = '1h', frequency = 400 } = options;
  const split = splitParenthesis(part);
  if (!split.before) return;

  const beforeMatch = /.*?(?<from>-?[0-9.]+)-?(?<to>-?[0-9.]*).*/.exec(
    split.before,
  );

  if (!beforeMatch || !beforeMatch.groups) return;

  const isARange = beforeMatch.groups.to !== '';

  const from = Number(beforeMatch.groups.from);
  const to = isARange ? Number(beforeMatch.groups.to) : from;
  const insideParts = split.inside.split(/ *, */);
  let signal: NMRSignal1D = { delta: NaN, js: [] };
  let range: NMRRange = { from, to, signals: [signal] };

  const integrationParts = insideParts.filter((part: any) =>
    part.match(/^[0-9]+H$/),
  );
  if (integrationParts.length === 1) {
    range.integration = Number(integrationParts[0].replace('H', ''));
  }

  const multiplicityParts = insideParts.filter((part: any) =>
    part.match(/^[a-zA-Z]+$/),
  );
  if (multiplicityParts.length === 1) {
    const multiplicity = multiplicityParts[0];
    if (multiplicity === 'm') {
      if (isARange) {
        // a real range
        signal.delta = (from + to) / 2;
        signal.multiplicity = multiplicity;
      } else {
        // a complex signal
        signal.delta = from;
        signal.multiplicity = multiplicity;
      }
    } else {
      // looks like a real multiplicity, s, d, dd, etc..
      if (!isARange) {
        // a complex signal
        signal.delta = from;
        signal.multiplicity = multiplicity;
      }
    }
  }

  const jCouplings = insideParts
    .filter((part: any) => part.match(/(Hz|J|^[0-9.]+$)/))
    .map((jCoupling: string) => Number(jCoupling.replace(/[^0-9.]/g, '')));

  const multiplicities = splitPatterns(signal.multiplicity || '');
  if (multiplicities.length === jCouplings.length) {
    for (let i = 0; i < multiplicities.length; i++) {
      if (!signal.js) {
        throw new Error('signal has not js');
      }
      signal.js.push({
        coupling: jCouplings[i],
        multiplicity: multiplicities[i],
      });
    }
  }

  if (range.from === range.to) {
    range = { ...range, ...rangeFromSignal(signal, { nucleus, frequency }) };
  }

  return range;
}
