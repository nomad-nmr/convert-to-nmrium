import { DataXY } from 'cheminfo-types';
import { gsd, optimizePeaks, joinBroadPeaks, appendShapeAndFWHM } from 'ml-gsd';
import type {
  GSDOptions,
  OptimizePeaksOptions,
  JoinBroadPeaksOptions,
} from 'ml-gsd';
import {
  xyExtract,
  xNoiseSanPlot,
  xAbsoluteMedian,
} from 'ml-spectra-processing';

import { NMRPeak1D } from '..';

/**
 * Implementation of the peak picking method described by Cobas in:
 * A new approach to improving automated analysis of proton NMR spectra
 * through Global Spectral Deconvolution (GSD)
 * http://www.spectrosco-pyeurope.com/images/stories/ColumnPDFs/TD_23_1.pdf
 */

interface OptionsGetCutOff {
  noiseLevel?: number;
  useSanPlot: boolean;
  thresholdFactor: number;
}

export interface GetPeakListOptions
  extends GSDOptions,
    OptimizePeaksOptions,
    JoinBroadPeaksOptions {
  /**
   * If it is true, the peaks parameters will be optimized.
   * @default false
   */
  optimize: boolean;
}
export interface OptionsXYAutoPeaksPicking extends Partial<GetPeakListOptions> {
  /**
   * Low limit value in the x axis to extract a sub set of points from the input data.
   */
  from?: number;
  /**
   * Upper limit value in the x axis to extract a sub set of points from the input data.
   */
  to?: number;
  /**
   * the factor that multiplies the noise level to set up a threshold to select peaks with respect to the intensity.
   * @default 3
   */
  thresholdFactor?: number;
  /**
   * If it is true, it check for negative peaks.
   * @default false
   */
  lookNegative?: boolean;
  /**
   * If it is true, it calculate the noise level by sanPlot method.
   * @default false
   */
  useSanPlot?: boolean;
}

export function xyAutoPeaksPicking(
  data: DataXY,
  options: OptionsXYAutoPeaksPicking = {},
): NMRPeak1D[] {
  const {
    from,
    to,
    noiseLevel,
    thresholdFactor = 3,
    minMaxRatio = 0.05,
    broadRatio = 0.00025,
    useSanPlot = false,
    smoothY = true,
    optimize = false,
    factorLimits = 4,
    realTopDetection = true,
    shape = { kind: 'gaussian' },
    optimization = { kind: 'lm' },
    broadWidth = 0.25,
    sgOptions = {},
    lookNegative = false,
  } = options;

  const { windowSize = 9, polynomial = 3 } = sgOptions;

  if (from !== undefined && to !== undefined) {
    data = xyExtract(data, { zones: [{ from, to }] });
  }
  if (data.x.length < windowSize) return [];

  const cutOff = getCutOff(data.y, { noiseLevel, useSanPlot, thresholdFactor });

  let getPeakOptions: GetPeakListOptions = {
    shape,
    broadWidth,
    optimize,
    factorLimits,
    maxCriteria: true,
    sgOptions: { windowSize, polynomial },
    minMaxRatio,
    broadRatio,
    noiseLevel: cutOff.positive,
    smoothY,
    optimization,
    realTopDetection,
  };

  let peaks = getPeakList(data, getPeakOptions);

  if (lookNegative) {
    getPeakOptions.noiseLevel = cutOff.negative;
    getPeakOptions.maxCriteria = false;
    peaks.push(...getPeakList(data, getPeakOptions));
  }
  return peaks;
}

function getPeakList(data: DataXY, options: GetPeakListOptions) {
  const {
    shape,
    broadWidth,
    optimize,
    maxCriteria,
    factorLimits,
    sgOptions,
    minMaxRatio,
    broadRatio,
    noiseLevel,
    smoothY,
    optimization,
    realTopDetection,
  } = options;

  let peakList = gsd(data, {
    sgOptions,
    maxCriteria,
    minMaxRatio,
    noiseLevel,
    smoothY,
    realTopDetection,
  });

  if (broadWidth) {
    peakList = joinBroadPeaks(peakList, {
      broadRatio,
      broadWidth,
      shape,
      optimization,
    });
  }

  if (optimize) {
    return optimizePeaks(data, peakList, {
      shape,
      factorLimits,
      optimization,
    });
  }

  return appendShapeAndFWHM(peakList, { shape });
}

function getCutOff(data: number[] | Float64Array, options: OptionsGetCutOff) {
  const { noiseLevel, useSanPlot, thresholdFactor } = options;

  const formatResult = (noiseLevel: number) =>
    typeof noiseLevel === 'number'
      ? { positive: noiseLevel, negative: -noiseLevel }
      : noiseLevel;

  if (noiseLevel) {
    return formatResult(noiseLevel);
  } else {
    return useSanPlot
      ? xNoiseSanPlot(data, { factorStd: thresholdFactor })
      : formatResult(xAbsoluteMedian(data) * thresholdFactor);
  }
}
