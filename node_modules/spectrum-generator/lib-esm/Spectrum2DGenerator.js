import { getShape2D } from 'ml-peak-shape-generator';
import { matrixMinMaxZ } from 'ml-spectra-processing';
const axis2D = ['x', 'y'];
const peakCoordinates = ['x', 'y', 'z'];
const convertWidthToFWHM = (shape, width) => {
    const widthData = ensureXYNumber(width);
    for (let key of axis2D) {
        widthData[key] = shape.widthToFWHM(widthData[key]);
    }
    return widthData;
};
export class Spectrum2DGenerator {
    constructor(options = {}) {
        let { from = 0, to = 100, nbPoints = 1001, peakWidthFct = () => 5, shape = {
            kind: 'gaussian',
        }, } = options;
        from = ensureXYNumber(from);
        to = ensureXYNumber(to);
        nbPoints = ensureXYNumber(nbPoints);
        for (const axis of axis2D) {
            assertNumber(from[axis], `from-${axis}`);
            assertNumber(to[axis], `to-${axis}`);
            assertInteger(nbPoints[axis], `nbPoints-${axis}`);
        }
        this.from = from;
        this.to = to;
        this.nbPoints = nbPoints;
        this.interval = calculeIntervals(from, to, nbPoints);
        this.peakWidthFct = peakWidthFct;
        this.maxPeakHeight = Number.MIN_SAFE_INTEGER;
        let shapeGenerator = getShape2D(shape);
        this.shape = shapeGenerator;
        this.data = {
            x: new Float64Array(nbPoints.x),
            y: new Float64Array(nbPoints.y),
            z: createMatrix(this.nbPoints),
        };
        for (const axis of axis2D) {
            if (this.to[axis] <= this.from[axis]) {
                throw new RangeError('to option must be larger than from');
            }
        }
        if (typeof this.peakWidthFct !== 'function') {
            throw new TypeError('peakWidthFct option must be a function');
        }
        this.reset();
    }
    addPeaks(peaks, options) {
        if (!Array.isArray(peaks) &&
            (typeof peaks !== 'object' ||
                peaks.x === undefined ||
                peaks.y === undefined ||
                !Array.isArray(peaks.x) ||
                !Array.isArray(peaks.y) ||
                peaks.x.length !== peaks.y.length)) {
            throw new TypeError('peaks must be an array or an object containing x[] and y[]');
        }
        if (Array.isArray(peaks)) {
            for (const peak of peaks) {
                this.addPeak(peak, options);
            }
        }
        else {
            let nbPeaks = peaks.x.length;
            for (const c of peakCoordinates) {
                if (peaks[c] && Array.isArray(peaks[c])) {
                    if (nbPeaks !== peaks[c].length) {
                        throw new Error('x, y, z should have the same length');
                    }
                }
            }
            for (let i = 0; i < peaks.x.length; i++) {
                this.addPeak([peaks.x[i], peaks.y[i], peaks.z[i]], options);
            }
        }
        return this;
    }
    addPeak(peak, options = {}) {
        if (Array.isArray(peak) && peak.length < 3) {
            throw new Error('peak must be an array with three (or four) values or an object with {x,y,z,width?}');
        }
        if (!Array.isArray(peak) &&
            peakCoordinates.some((e) => peak[e] === undefined)) {
            throw new Error('peak must be an array with three (or four) values or an object with {x,y,z,width?}');
        }
        let xPosition;
        let yPosition;
        let intensity;
        let peakFWHM;
        let peakWidth;
        let peakShapeOptions;
        if (Array.isArray(peak)) {
            [xPosition, yPosition, intensity, peakFWHM, peakShapeOptions] = peak;
        }
        else {
            xPosition = peak.x;
            yPosition = peak.y;
            intensity = peak.z;
            peakFWHM = peak.fwhm;
            peakWidth = peak.width;
            peakShapeOptions = peak.shape;
        }
        const position = { x: xPosition, y: yPosition };
        if (intensity > this.maxPeakHeight)
            this.maxPeakHeight = intensity;
        let { shape: shapeOptions, width } = options;
        if (peakShapeOptions) {
            shapeOptions = shapeOptions
                ? { ...shapeOptions, ...peakShapeOptions }
                : peakShapeOptions;
        }
        if (shapeOptions) {
            this.shape = getShape2D(shapeOptions);
        }
        let { fwhm = peakFWHM !== undefined
            ? peakFWHM
            : peakWidth
                ? convertWidthToFWHM(this.shape, peakWidth)
                : width
                    ? convertWidthToFWHM(this.shape, width)
                    : this.peakWidthFct(xPosition, yPosition), } = options;
        fwhm = ensureXYNumber(fwhm);
        let factor = options.factor === undefined ? this.shape.getFactor() : options.factor;
        factor = ensureXYNumber(factor);
        const firstPoint = { x: 0, y: 0 };
        const lastPoint = { x: 0, y: 0 };
        for (const axis of axis2D) {
            const first = position[axis] - (fwhm[axis] / 2) * factor[axis];
            const last = position[axis] + (fwhm[axis] / 2) * factor[axis];
            firstPoint[axis] = Math.max(0, Math.floor((first - this.from[axis]) / this.interval[axis]));
            lastPoint[axis] = Math.min(this.nbPoints[axis], Math.ceil((last - this.from[axis]) / this.interval[axis]));
        }
        this.shape.fwhm = fwhm;
        for (let xIndex = firstPoint.x; xIndex < lastPoint.x; xIndex++) {
            for (let yIndex = firstPoint.y; yIndex < lastPoint.y; yIndex++) {
                const value = intensity *
                    this.shape.fct(this.data.x[xIndex] - position.x, this.data.y[yIndex] - position.y);
                if (value > 1e-6) {
                    this.data.z[yIndex][xIndex] += value;
                }
            }
        }
        return this;
    }
    getSpectrum(options = {}) {
        if (typeof options === 'boolean') {
            options = { copy: options };
        }
        const { copy = true } = options;
        let minMaxZ = matrixMinMaxZ(this.data.z);
        return {
            minX: this.from.x,
            maxX: this.to.x,
            maxY: this.to.y,
            minY: this.from.y,
            minZ: minMaxZ.min,
            maxZ: minMaxZ.max,
            z: copy ? this.data.z.slice() : this.data.z,
        };
    }
    reset() {
        const spectrum = this.data;
        for (const axis of axis2D) {
            for (let i = 0; i < this.nbPoints[axis]; i++) {
                spectrum[axis][i] = this.from[axis] + i * this.interval[axis];
            }
        }
        for (let row of spectrum.z) {
            for (let j = 0; j < row.length; j++) {
                row[j] = 0;
            }
        }
        return this;
    }
}
export function generateSpectrum2D(peaks, options = {}) {
    const { generator: generatorOptions, peaks: addPeaksOptions } = options;
    const generator = new Spectrum2DGenerator(generatorOptions);
    generator.addPeaks(peaks, addPeaksOptions);
    return generator.getSpectrum();
}
function ensureXYNumber(input) {
    let result = typeof input !== 'object' ? { x: input, y: input } : input;
    return result;
}
function calculeIntervals(from, to, nbPoints) {
    return {
        x: (to.x - from.x) / (nbPoints.x - 1),
        y: (to.y - from.y) / (nbPoints.y - 1),
    };
}
function assertInteger(value, name) {
    if (!Number.isInteger(value)) {
        throw new TypeError(`${name} option must be an integer`);
    }
}
function assertNumber(value, name) {
    if (!Number.isFinite(value)) {
        throw new TypeError(`${name} option must be a number`);
    }
}
function createMatrix(nbPoints) {
    const zMatrix = new Array(nbPoints.y);
    for (let i = 0; i < nbPoints.y; i++) {
        zMatrix[i] = new Float64Array(nbPoints.x);
    }
    return zMatrix;
}
//# sourceMappingURL=Spectrum2DGenerator.js.map