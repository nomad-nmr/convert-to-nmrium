"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSpectrum = exports.SpectrumGenerator = void 0;
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
const addBaseline_1 = __importDefault(require("./util/addBaseline"));
const addNoise_1 = __importDefault(require("./util/addNoise"));
class SpectrumGenerator {
    constructor(options = {}) {
        const { from = 0, to = 1000, nbPoints = 10001, peakWidthFct, shape = { kind: 'gaussian', fwhm: 5 }, } = options;
        this.from = from;
        this.to = to;
        this.nbPoints = nbPoints;
        this.interval = (this.to - this.from) / (this.nbPoints - 1);
        this.peakWidthFct = peakWidthFct;
        this.maxPeakHeight = Number.MIN_SAFE_INTEGER;
        this.data = {
            x: new Float64Array(this.nbPoints),
            y: new Float64Array(this.nbPoints),
        };
        let shapeGenerator = (0, ml_peak_shape_generator_1.getShape1D)(shape);
        this.shape = shapeGenerator;
        assertNumber(this.from, 'from');
        assertNumber(this.to, 'to');
        assertInteger(this.nbPoints, 'nbPoints');
        if (this.to <= this.from) {
            throw new RangeError('to option must be larger than from');
        }
        if (this.peakWidthFct && typeof this.peakWidthFct !== 'function') {
            throw new TypeError('peakWidthFct option must be a function');
        }
        this.reset();
    }
    /**
     * Add a series of peaks to the spectrum.
     * @param peaks - Peaks to add.
     */
    addPeaks(peaks, options) {
        if (!Array.isArray(peaks) &&
            (typeof peaks !== 'object' ||
                peaks.x === undefined ||
                peaks.y === undefined ||
                !Array.isArray(peaks.x) ||
                !Array.isArray(peaks.y) ||
                peaks.x.length !== peaks.y.length)) {
            throw new TypeError('peaks must be an array or an object containing x[] and y[]');
        }
        if (Array.isArray(peaks)) {
            for (const peak of peaks) {
                this.addPeak(peak, options);
            }
        }
        else {
            for (let i = 0; i < peaks.x.length; i++) {
                this.addPeak([peaks.x[i], peaks.y[i]], options);
            }
        }
    }
    /**
     * Add a single peak to the spectrum.
     * A peak may be either defined as [x,y,fwhm,...] or as {x, y, shape}
     * @param peak
     * @param options
     */
    addPeak(peak, options = {}) {
        if (Array.isArray(peak) && peak.length < 2) {
            throw new Error('peak must be an array with two (or three) values or an object with {x,y,width?}');
        }
        if (!Array.isArray(peak) &&
            (peak.x === undefined || peak.y === undefined)) {
            throw new Error('peak must be an array with two (or three) values or an object with {x,y,width?}');
        }
        let xPosition;
        let intensity;
        let peakFWHM;
        let peakWidth;
        let peakShapeOptions;
        if (Array.isArray(peak)) {
            [xPosition, intensity, peakFWHM, peakShapeOptions] = peak;
        }
        else {
            xPosition = peak.x;
            intensity = peak.y;
            peakWidth = peak.width;
            peakShapeOptions = peak.shape;
        }
        if (intensity > this.maxPeakHeight)
            this.maxPeakHeight = intensity;
        let { shape: shapeOptions } = options;
        if (peakShapeOptions) {
            shapeOptions = shapeOptions
                ? { ...shapeOptions, ...peakShapeOptions }
                : peakShapeOptions;
        }
        if (shapeOptions) {
            this.shape = (0, ml_peak_shape_generator_1.getShape1D)(shapeOptions);
        }
        let { widthLeft, widthRight } = options;
        /*
         if we don't force the fwhm we just take the one from the shape
         however we have many way to force it:
         - use [x,y,fwhm]
         - define `width` that will be converted to fwhm
         - define `widthLeft` and `widthRight` to define asymmetric peaks
         - have a callback `peakWidthFct`
         This should evolve in the future because we will not always have `fwhm`
         */
        const fwhm = peakFWHM !== undefined
            ? peakFWHM
            : peakWidth
                ? this.shape.widthToFWHM(peakWidth)
                : this.peakWidthFct
                    ? this.peakWidthFct(xPosition)
                    : this.shape.fwhm;
        if (!widthLeft)
            widthLeft = fwhm;
        if (!widthRight)
            widthRight = fwhm;
        if (!widthLeft || !widthRight) {
            throw new Error('Width left or right is undefined or zero');
        }
        let factor = options.factor === undefined ? this.shape.getFactor() : options.factor;
        const firstValue = xPosition - (widthLeft / 2) * factor;
        const lastValue = xPosition + (widthRight / 2) * factor;
        const firstPoint = Math.max(0, Math.floor((firstValue - this.from) / this.interval));
        const lastPoint = Math.min(this.nbPoints - 1, Math.ceil((lastValue - this.from) / this.interval));
        const middlePoint = Math.round((xPosition - this.from) / this.interval);
        // PEAK SHAPE MAY BE ASYMMETRC (widthLeft and widthRight) !
        // we calculate the left part of the shape
        this.shape.fwhm = widthLeft;
        for (let index = firstPoint; index < Math.max(middlePoint, 0); index++) {
            this.data.y[index] +=
                intensity * this.shape.fct(this.data.x[index] - xPosition);
        }
        // we calculate the right part of the gaussian
        this.shape.fwhm = widthRight;
        for (let index = Math.min(middlePoint, lastPoint); index <= lastPoint; index++) {
            this.data.y[index] +=
                intensity * this.shape.fct(this.data.x[index] - xPosition);
        }
    }
    /**
     * Add a baseline to the spectrum.
     * @param baselineFct - Mathematical function producing the baseline you want.
     */
    addBaseline(baselineFct) {
        (0, addBaseline_1.default)(this.data, baselineFct);
        return this;
    }
    /**
     * Add noise to the spectrum.
     *
     * @param percent - Noise's amplitude in percents of the spectrum max value. Default: 1.
     */
    addNoise(options) {
        (0, addNoise_1.default)(this.data, options);
        return this;
    }
    /**
     * Get the generated spectrum.
     */
    getSpectrum(options = {}) {
        if (typeof options === 'boolean') {
            options = { copy: options };
        }
        const { copy = true, threshold = 0 } = options;
        if (threshold) {
            let minPeakHeight = this.maxPeakHeight * threshold;
            let x = [];
            let y = [];
            for (let i = 0; i < this.data.x.length; i++) {
                if (this.data.y[i] >= minPeakHeight) {
                    x.push(this.data.x[i]);
                    y.push(this.data.y[i]);
                }
            }
            return { x, y };
        }
        if (copy) {
            return {
                x: this.data.x.slice(),
                y: this.data.y.slice(),
            };
        }
        else {
            return this.data;
        }
    }
    /**
     * Resets the generator with an empty spectrum.
     */
    reset() {
        const spectrum = this.data;
        for (let i = 0; i < this.nbPoints; i++) {
            spectrum.x[i] = this.from + i * this.interval;
        }
        return this;
    }
}
exports.SpectrumGenerator = SpectrumGenerator;
function assertInteger(value, name) {
    if (!Number.isInteger(value)) {
        throw new TypeError(`${name} option must be an integer`);
    }
}
function assertNumber(value, name) {
    if (!Number.isFinite(value)) {
        throw new TypeError(`${name} option must be a number`);
    }
}
/**
 * Generates a spectrum and returns it.
 * @param peaks - List of peaks to put in the spectrum.
 * @param options
 */
function generateSpectrum(peaks, options = {}) {
    const { generator: generatorOptions, noise, baseline, threshold, peakOptions, } = options;
    const generator = new SpectrumGenerator(generatorOptions);
    generator.addPeaks(peaks, peakOptions);
    if (baseline)
        generator.addBaseline(baseline);
    if (noise) {
        generator.addNoise(noise);
    }
    return generator.getSpectrum({
        threshold,
    });
}
exports.generateSpectrum = generateSpectrum;
//# sourceMappingURL=SpectrumGenerator.js.map