import type { DataXY } from 'cheminfo-types';
import type { Shape1D } from 'ml-peak-shape-generator';
import type { PeakSeries, Peak1D } from './types/Peaks1D';
import type { NoiseOptions } from './util/addNoise';
declare type NumToNumFn = (x: number) => number;
interface OptionsSG1D {
    /**
     * First x value (inclusive).
     * @default 0
     */
    from?: number;
    /**
     * Last x value (inclusive).
     * @default 1000
     */
    to?: number;
    /**
     * Number of points in the final spectrum.
     * @default 10001
     */
    nbPoints?: number;
    /**
     * Function that returns the width of a peak depending the x value.
     * @default "() => 5"
     */
    peakWidthFct?: NumToNumFn;
    /**
     * Define the shape of the peak.
     * @default "{kind: 'gaussian'}"
     */
    shape?: Shape1D;
}
interface PeakOptions {
    /**
     * Half-height width.
     * @default `peakWidthFct(value)`
     */
    width?: number;
    /**
     * Half-height width left (asymmetric peak).
     * @default `fwhm`
     */
    widthLeft?: number;
    /**
     * Half-height width right (asymmetric peak).
     * @default `fwhm`
     */
    widthRight?: number;
    /**
     * Shape options
     */
    shape?: Shape1D;
    /**
     * Number of times of fwhm to calculate length..
     * @default 'covers 99.99 % of surface'
     */
    factor?: number;
}
interface GenerateSpectrumOptions {
    /**
     * Options for spectrum generator
     */
    generator?: OptionsSG1D;
    /**
     * Function to generate or add a baseline
     */
    baseline?: NumToNumFn;
    /**
     * Options to add noise to the spectrum
     */
    noise?: NoiseOptions;
    /**
     * Options for addPeaks method
     */
    peakOptions?: PeakOptions;
    /**
     * minimum intensity value
     * @default 0
     */
    threshold?: number;
}
export interface GetSpectrumOptions {
    /**
     * generate a copy of the current data
     * @default true
     */
    copy?: boolean;
    /**
     * minimum intensity value
     * @default 0
     */
    threshold?: number;
}
export declare class SpectrumGenerator {
    private from;
    private to;
    private nbPoints;
    interval: number;
    private peakWidthFct;
    private maxPeakHeight;
    private shape;
    private data;
    constructor(options?: OptionsSG1D);
    /**
     * Add a series of peaks to the spectrum.
     * @param peaks - Peaks to add.
     */
    addPeaks(peaks: Peak1D[] | PeakSeries, options?: PeakOptions): void;
    /**
     * Add a single peak to the spectrum.
     * A peak may be either defined as [x,y,fwhm,...] or as {x, y, shape}
     * @param peak
     * @param options
     */
    addPeak(peak: Peak1D, options?: PeakOptions): void;
    /**
     * Add a baseline to the spectrum.
     * @param baselineFct - Mathematical function producing the baseline you want.
     */
    addBaseline(baselineFct: NumToNumFn): this;
    /**
     * Add noise to the spectrum.
     *
     * @param percent - Noise's amplitude in percents of the spectrum max value. Default: 1.
     */
    addNoise(options?: NoiseOptions): this;
    /**
     * Get the generated spectrum.
     */
    getSpectrum(options?: GetSpectrumOptions | boolean): DataXY<import("cheminfo-types").DoubleArray>;
    /**
     * Resets the generator with an empty spectrum.
     */
    reset(): this;
}
/**
 * Generates a spectrum and returns it.
 * @param peaks - List of peaks to put in the spectrum.
 * @param options
 */
export declare function generateSpectrum(peaks: Peak1D[] | PeakSeries, options?: GenerateSpectrumOptions): DataXY;
export {};
