"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reimFFT = void 0;
const fft_js_1 = __importDefault(require("fft.js"));
const xRotate_1 = require("../x/xRotate");
/**
 * ReimFFT.
 *
 * @param data - complex spectrum
 * @param options - options.
 * @returns FFT of complex spectrum.
 */
function reimFFT(data, options = {}) {
    const { inverse = false, applyZeroShift = false } = options;
    let { re, im } = data;
    const size = re.length;
    const csize = size << 1;
    let complexArray = new Float64Array(csize);
    for (let i = 0; i < csize; i += 2) {
        complexArray[i] = re[i >>> 1];
        complexArray[i + 1] = im[i >>> 1];
    }
    let fft = new fft_js_1.default(size);
    let output = new Float64Array(csize);
    if (inverse) {
        if (applyZeroShift)
            complexArray = zeroShift(complexArray, true);
        fft.inverseTransform(output, complexArray);
    }
    else {
        fft.transform(output, complexArray);
        if (applyZeroShift)
            output = zeroShift(output);
    }
    let newRe = new Float64Array(size);
    let newIm = new Float64Array(size);
    for (let i = 0; i < csize; i += 2) {
        newRe[i >>> 1] = output[i];
        newIm[i >>> 1] = output[i + 1];
    }
    return { re: newRe, im: newIm };
}
exports.reimFFT = reimFFT;
const zeroShift = (data, inverse) => {
    let middle = inverse
        ? Math.ceil(data.length / 2)
        : Math.floor(data.length / 2);
    return (0, xRotate_1.xRotate)(data, middle);
};
//# sourceMappingURL=reimFFT.js.map