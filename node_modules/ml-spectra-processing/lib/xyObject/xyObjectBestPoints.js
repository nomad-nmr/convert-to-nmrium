"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyObjectBestPoints = void 0;
const xyObjectMaxXPoint_1 = require("./xyObjectMaxXPoint");
const xyObjectMinXPoint_1 = require("./xyObjectMinXPoint");
/**
 * Filter the array by taking the higher points (max y value) and only.
 * Keep one per slot. There are 2 different slots, the smallest one will have the
 * new property `close` to true
 *
 * @param points - array of all the points
 * @param options - Options
 * @returns - copy of points with 'close' property
 */
function xyObjectBestPoints(points, options = {}) {
    const { from = (0, xyObjectMinXPoint_1.xyObjectMinXPoint)(points).x, to = (0, xyObjectMaxXPoint_1.xyObjectMaxXPoint)(points).x, limit = 20, threshold = 0.01, numberCloseSlots = 50, numberSlots = 10, } = options;
    let slot = (to - from) / numberSlots;
    let closeSlot = (to - from) / numberCloseSlots;
    let selected = points
        .filter((point) => point.x >= from && point.x <= to)
        .map((point) => {
        return {
            point,
            monoisotopic: false,
        };
    });
    selected = selected.sort((a, b) => {
        if (a.monoisotopic && !b.monoisotopic)
            return -1;
        if (b.monoisotopic && !a.monoisotopic)
            return 1;
        return b.point.y - a.point.y;
    });
    let toReturn = [];
    if (selected.length === 0)
        return [];
    let minY = selected[0].point.y * threshold;
    peakLoop: for (let item of selected) {
        if (item.point.y < minY) {
            if (item.monoisotopic) {
                continue;
            }
            else {
                break;
            }
        }
        let close = false;
        for (let existing of toReturn) {
            if (Math.abs(existing.x - item.point.x) < closeSlot) {
                continue peakLoop;
            }
            if (Math.abs(existing.x - item.point.x) < slot) {
                close = true;
            }
        }
        let newPeak = JSON.parse(JSON.stringify(item.point));
        newPeak.close = close;
        toReturn.push(newPeak);
        if (toReturn.length === limit)
            break;
    }
    return toReturn.sort((a, b) => a.x - b.x);
}
exports.xyObjectBestPoints = xyObjectBestPoints;
//# sourceMappingURL=xyObjectBestPoints.js.map