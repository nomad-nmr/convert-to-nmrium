"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyEquallySpaced = void 0;
const createFromToArray_1 = require("../utils/createFromToArray");
const zoneCheck_1 = require("../zone/zoneCheck");
const zonesInvert_1 = require("../zones/zonesInvert");
const zonesWithPoints_1 = require("../zones/zonesWithPoints");
const equallySpacedSlot_1 = __importDefault(require("./utils/equallySpacedSlot"));
const equallySpacedSmooth_1 = __importDefault(require("./utils/equallySpacedSmooth"));
/**
 * Function that returns a Number array of equally spaced numberOfPoints
 * containing a representation of intensities of the spectra arguments x
 * and y.
 *
 * The options parameter contains an object in the following form:
 * from: starting point
 * to: last point
 * numberOfPoints: number of points between from and to
 * variant: "slot" or "smooth" - smooth is the default option
 *
 * The slot variant consist that each point in an array is calculated
 * averaging the existing points between the slot that belongs to the current
 * value. The smooth variant is the same but takes the integral of the range
 * of the slot and divide by the step size between two points in an array.
 *
 * If exclusions zone are present, zones are ignored !
 *
 * @param arrayXY - object containing 2 properties x and y
 * @param options - options
 * @return new object with x / y array with the equally spaced data.
 */
function xyEquallySpaced(arrayXY, options = {}) {
    let { x, y } = arrayXY;
    let xLength = x.length;
    let { from = x[0], to = x[xLength - 1], variant = 'smooth', numberOfPoints = 100, exclusions = [], zones = [], } = options;
    let reverse = false;
    if (x.length > 1 && x[0] > x[1]) {
        x = x.slice().reverse();
        y = y.slice().reverse();
        reverse = true;
    }
    if (!(0, zoneCheck_1.zoneCheck)(arrayXY)) {
        throw new RangeError("the x and y vector doesn't have the same size.");
    }
    if (typeof from !== 'number' || isNaN(from)) {
        throw new RangeError("'from' option must be a number");
    }
    if (typeof to !== 'number' || isNaN(to)) {
        throw new RangeError("'to' option must be a number");
    }
    if (typeof numberOfPoints !== 'number' || isNaN(numberOfPoints)) {
        throw new RangeError("'numberOfPoints' option must be a number");
    }
    if (numberOfPoints < 2) {
        throw new RangeError("'numberOfPoints' option must be greater than 1");
    }
    if (zones.length === 0) {
        zones = (0, zonesInvert_1.zonesInvert)(exclusions, { from, to });
    }
    let zonesWithPointsRes = (0, zonesWithPoints_1.zonesWithPoints)(zones, numberOfPoints, { from, to });
    let xResult = [];
    let yResult = [];
    for (let zone of zonesWithPointsRes) {
        if (!zone.numberOfPoints) {
            zone.numberOfPoints = 0;
        }
        let zoneResult = processZone(Array.from(x), Array.from(y), zone.from, zone.to, zone.numberOfPoints, variant);
        xResult = xResult.concat(zoneResult.x);
        yResult = yResult.concat(zoneResult.y);
    }
    if (reverse) {
        if (from < to) {
            return { x: xResult.reverse(), y: yResult.reverse() };
        }
        else {
            return { x: xResult, y: yResult };
        }
    }
    else {
        if (from < to) {
            return { x: xResult, y: yResult };
        }
        else {
            return { x: xResult.reverse(), y: yResult.reverse() };
        }
    }
}
exports.xyEquallySpaced = xyEquallySpaced;
function processZone(x, y, from, to, numberOfPoints, variant) {
    if (numberOfPoints < 1) {
        throw new RangeError('the number of points must be at least 1');
    }
    let output = variant === 'slot'
        ? Array.from((0, equallySpacedSlot_1.default)(x, y, from, to, numberOfPoints))
        : Array.from((0, equallySpacedSmooth_1.default)(x, y, from, to, numberOfPoints));
    return {
        x: Array.from((0, createFromToArray_1.createFromToArray)({
            from,
            to,
            length: numberOfPoints,
        })),
        y: output,
    };
}
//# sourceMappingURL=xyEquallySpaced.js.map