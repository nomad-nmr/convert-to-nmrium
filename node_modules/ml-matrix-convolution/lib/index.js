'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mlFft = require('ml-fft');

function LoG(sigma, nPoints, options) {
  let factor = 1000;
  if (options && options.factor) {
    factor = options.factor;
  }

  let kernel = new Array(nPoints);
  let tmp, y2;

  factor *= -1; //-1/(Math.PI*Math.pow(sigma,4));
  let center = (nPoints - 1) / 2;
  let sigma2 = 2 * sigma * sigma;
  for (let i = 0; i < nPoints; i++) {
    kernel[i] = new Array(nPoints);
    y2 = (i - center) * (i - center);
    for (let j = 0; j < nPoints; j++) {
      tmp = -((j - center) * (j - center) + y2) / sigma2;
      kernel[i][j] = Math.round(factor * (1 + tmp) * Math.exp(tmp));
    }
  }

  return kernel;
}

function matrix2Array(input) {
  let inputData = input;
  let nRows, nCols;
  if (typeof input[0] !== 'number') {
    nRows = input.length;
    nCols = input[0].length;
    inputData = new Array(nRows * nCols);
    for (let i = 0; i < nRows; i++) {
      for (let j = 0; j < nCols; j++) {
        inputData[i * nCols + j] = input[i][j];
      }
    }
  } else {
    let tmp = Math.sqrt(input.length);
    if (Number.isInteger(tmp)) {
      nRows = tmp;
      nCols = tmp;
    }
  }

  return { data: inputData, rows: nRows, cols: nCols };
}

function convolutionFFT(input, kernel, opt) {
  let tmp = matrix2Array(input);
  let inputData = tmp.data;
  let options = Object.assign(
    { normalize: false, divisor: 1, rows: tmp.rows, cols: tmp.cols },
    opt,
  );

  let nRows, nCols;
  if (options.rows && options.cols) {
    nRows = options.rows;
    nCols = options.cols;
  } else {
    throw new Error(`Invalid number of rows or columns ${nRows} ${nCols}`);
  }

  let divisor = options.divisor;
  let kHeight = kernel.length;
  let kWidth = kernel[0].length;
  if (options.normalize) {
    divisor = 0;
    for (let i = 0; i < kHeight; i++) {
      for (let j = 0; j < kWidth; j++) divisor += kernel[i][j];
    }
  }
  if (divisor === 0) {
    throw new RangeError('convolution: The divisor is equal to zero');
  }

  let radix2Sized = mlFft.FFTUtils.toRadix2(inputData, nRows, nCols);
  let conv = mlFft.FFTUtils.convolute(
    radix2Sized.data,
    kernel,
    radix2Sized.rows,
    radix2Sized.cols,
  );
  conv = mlFft.FFTUtils.crop(conv, radix2Sized.rows, radix2Sized.cols, nRows, nCols);

  if (divisor !== 0 && divisor !== 1) {
    for (let i = 0; i < conv.length; i++) {
      conv[i] /= divisor;
    }
  }

  return conv;
}

function convolutionDirect(input, kernel, opt) {
  let tmp = matrix2Array(input);
  let inputData = tmp.data;
  let options = Object.assign(
    { normalize: false, divisor: 1, rows: tmp.rows, cols: tmp.cols },
    opt,
  );

  let nRows, nCols;
  if (options.rows && options.cols) {
    nRows = options.rows;
    nCols = options.cols;
  } else {
    throw new Error(`Invalid number of rows or columns ${nRows} ${nCols}`);
  }

  let divisor = options.divisor;
  let kHeight = kernel.length;
  let kWidth = kernel[0].length;
  let index, sum, kVal, row, col;
  if (options.normalize) {
    divisor = 0;
    for (let i = 0; i < kHeight; i++) {
      for (let j = 0; j < kWidth; j++) divisor += kernel[i][j];
    }
  }
  if (divisor === 0) {
    throw new RangeError('convolution: The divisor is equal to zero');
  }

  let output = new Array(nRows * nCols);

  let hHeight = Math.floor(kHeight / 2);
  let hWidth = Math.floor(kWidth / 2);

  for (let y = 0; y < nRows; y++) {
    for (let x = 0; x < nCols; x++) {
      sum = 0;
      for (let j = 0; j < kHeight; j++) {
        for (let i = 0; i < kWidth; i++) {
          kVal = kernel[kHeight - j - 1][kWidth - i - 1];
          row = (y + j - hHeight + nRows) % nRows;
          col = (x + i - hWidth + nCols) % nCols;
          index = row * nCols + col;
          sum += inputData[index] * kVal;
        }
      }
      index = y * nCols + x;
      output[index] = sum / divisor;
    }
  }
  return output;
}

const kernelFactory = {
  LoG: LoG,
};

exports.direct = convolutionDirect;
exports.fft = convolutionFFT;
exports.kernelFactory = kernelFactory;
exports.matrix2Array = matrix2Array;
