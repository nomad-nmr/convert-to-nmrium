'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var floydWarshall = require('ml-floyd-warshall');
var mlMatrix = require('ml-matrix');
var atomSorter = require('atom-sorter');
var ensureString = require('ensure-string');
var Papa = require('papaparse');
var sdfParser = require('sdf-parser');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var floydWarshall__default = /*#__PURE__*/_interopDefaultLegacy(floydWarshall);
var atomSorter__default = /*#__PURE__*/_interopDefaultLegacy(atomSorter);
var Papa__default = /*#__PURE__*/_interopDefaultLegacy(Papa);

let xAtomicNumber = 0;

/**
 * Tag an atom to be able to visualize it
 * @param {OCL.Molecule} molecule
 * @param {number} iAtom
 */
function tagAtom(molecule, iAtom) {
  let customLabel = `${molecule.getAtomLabel(iAtom)}*`;
  molecule.setAtomCustomLabel(iAtom, customLabel);
  if (molecule.getAtomicNo(iAtom) === 1) {
    molecule.setAtomicNo(iAtom, getXAtomicNumber(molecule));
  } else {
    // we can not use X because we would have problems with valencies if it is
    // expanded hydrogens or not
    // we can not only use a custom label because it does not count for the canonisation
    molecule.setAtomMass(iAtom, molecule.getAtomMass(iAtom) + 5);
  }
  return customLabel;
}

function getXAtomicNumber(molecule) {
  if (!xAtomicNumber) {
    const OCL = molecule.getOCL();
    xAtomicNumber = OCL.Molecule.getAtomicNoFromLabel('X');
  }
  return xAtomicNumber;
}

/**
 * Add either missing chirality of diastereotopic missing chirality
 * The problem is that sometimes we need to add chiral bond that was not planned because it is the same group
 * This is the case for example for the valine where the 2 C of the methyl groups are diastereotopic
 * @param {OCL.Molecule} molecule
 * @param {object} [options={}]
 * @param {number} [options.esrType=cESRTypeAnd]
 */
function addDiastereotopicMissingChirality(molecule, options = {}) {
  const { Molecule } = molecule.getOCL();
  const { esrType = Molecule.cESRTypeAnd } = options;

  for (let iAtom = 0; iAtom < molecule.getAllAtoms(); iAtom++) {
    let tempMolecule = molecule.getCompactCopy();
    tagAtom(tempMolecule, iAtom);
    // After copy, helpers must be recalculated
    tempMolecule.ensureHelperArrays(Molecule.cHelperBitsStereo);
    // We need to have >0 and not >1 because there could be unspecified chirality in racemate

    for (let i = 0; i < tempMolecule.getAtoms(); i++) {
      // changed from from handling below; TLS 9.Nov.2015
      if (
        tempMolecule.isAtomStereoCenter(i) &&
        tempMolecule.getStereoBond(i) === -1
      ) {
        let stereoBond = tempMolecule.getAtomPreferredStereoBond(i);
        if (stereoBond !== -1) {
          molecule.setBondType(stereoBond, Molecule.cBondTypeUp);
          if (molecule.getBondAtom(1, stereoBond) === i) {
            let connAtom = molecule.getBondAtom(0, stereoBond);
            molecule.setBondAtom(0, stereoBond, i);
            molecule.setBondAtom(1, stereoBond, connAtom);
          }
          // To me it seems that we have to add all stereo centers into AND group 0. TLS 9.Nov.2015
          molecule.setAtomESR(i, esrType, 0);
        }
      }
    }
  }
}

/**
 *
 * @param {OCL.Molecule} [molecule] An instance of a molecule
 * @param {object} [options={}]
 * @param {object} [options.OCL] openchemlib library
 */
function makeRacemic(molecule) {
  const { Molecule } = molecule.getOCL();

  // if we don't calculate this we have 2 epimers
  molecule.ensureHelperArrays(Molecule.cHelperCIP);

  // we need to make one group "AND" for chiral (to force to racemic, this means diastereotopic and not enantiotopic)
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (molecule.getAtomParity(i) !== Molecule.cAtomParityNone) {
      molecule.setAtomESR(i, Molecule.cESRTypeAnd, 0); // changed to group 0; TLS 9.Nov.2015
    }
  }
}

/**
 * Returns an array of diastereotopic ID (as oclCode)
 * @param {OCL.Molecule} molecule
 */
function getDiastereotopicAtomIDs(molecule) {
  const OCL = molecule.getOCL();
  addDiastereotopicMissingChirality(molecule);

  let numberAtoms = molecule.getAllAtoms();
  let ids = [];
  for (let iAtom = 0; iAtom < numberAtoms; iAtom++) {
    let tempMolecule = molecule.getCompactCopy();
    tagAtom(tempMolecule, iAtom);
    makeRacemic(tempMolecule);
    // We need to ensure the helper array in order to get correctly the result of racemisation
    ids[iAtom] = tempMolecule.getCanonizedIDCode(
      OCL.Molecule.CANONIZER_ENCODE_ATOM_CUSTOM_LABELS,
    );
  }
  return ids;
}

// Previously getExtendedDiastereotopicAtomIDs

/**
 *
 * @param {OCL.Molecule} molecule
 */
function getDiastereotopicAtomIDsAndH(molecule) {
  const OCL = molecule.getOCL();
  molecule = molecule.getCompactCopy();
  molecule.addImplicitHydrogens();
  // TODO Temporary code ???
  molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);

  const diaIDs = getDiastereotopicAtomIDs(molecule);
  const newDiaIDs = [];

  for (let i = 0; i < diaIDs.length; i++) {
    const diaID = diaIDs[i];
    const newDiaID = {
      oclID: diaID,
      hydrogenOCLIDs: [],
      nbHydrogens: 0,
    };
    if (molecule.getAtomicNo(i) === 1) {
      const atom = molecule.getConnAtom(i, 0);
      newDiaID.heavyAtom = diaIDs[atom];
    }
    for (let j = 0; j < molecule.getAllConnAtoms(i); j++) {
      const atom = molecule.getConnAtom(i, j);
      if (molecule.getAtomicNo(atom) === 1) {
        newDiaID.nbHydrogens++;
        if (newDiaID.hydrogenOCLIDs.indexOf(diaIDs[atom]) === -1) {
          newDiaID.hydrogenOCLIDs.push(diaIDs[atom]);
        }
      }
    }

    newDiaIDs.push(newDiaID);
  }

  return newDiaIDs;
}

/**
 * Returns a SVG
 * @param {*} molecule
 * @param {*} [options={}]
 */
function toDiastereotopicSVG(molecule, options = {}) {
  let {
    width = 300,
    height = 200,
    prefix = 'ocl',
    heavyAtomHydrogen = false,
  } = options;
  let svg = options.svg;
  let diaIDs = [];

  let hydrogenInfo = {};
  getDiastereotopicAtomIDsAndH(molecule).forEach((line) => {
    hydrogenInfo[line.oclID] = line;
  });

  if (heavyAtomHydrogen) {
    for (let i = 0; i < molecule.getAtoms(); i++) {
      diaIDs.push([]);
    }
    let groupedDiaIDs = molecule.getGroupedDiastereotopicAtomIDs();
    groupedDiaIDs.forEach((diaID) => {
      if (
        hydrogenInfo[diaID.oclID] &&
        hydrogenInfo[diaID.oclID].nbHydrogens > 0
      ) {
        diaID.atoms.forEach((atom) => {
          hydrogenInfo[diaID.oclID].hydrogenOCLIDs.forEach((id) => {
            if (!diaIDs[atom * 1].includes(id)) diaIDs[atom].push(id);
          });
        });
      }
    });
  } else {
    diaIDs = molecule.getDiastereotopicAtomIDs().map((a) => [a]);
  }

  if (!svg) svg = molecule.toSVG(width, height, prefix);

  svg = svg.replace(/Atom:[0-9]+"/g, (value) => {
    let atom = value.replace(/[^0-9]/g, '');
    return `${value} data-diaid="${diaIDs[atom].join(',')}"`;
  });

  return svg;
}

/**
 * This function groups the diasterotopic atomIds of the molecule based on equivalence of atoms. The output object contains
 * a set of chemically equivalent atoms(element.atoms) and the groups of magnetically equivalent atoms (element.magneticGroups)
 * @param {OCL.Molecule} molecule
 * @param {object} [options={}]
 * @param {string} [options.atomLabel] Select atoms of the given atomLabel. By default it returns all the explicit atoms in the molecule
 * @returns {Array}
 */

function getGroupedDiastereotopicAtomIDs(molecule, options = {}) {
  const { atomLabel } = options;
  let diaIDs = getDiastereotopicAtomIDs(molecule);
  let diaIDsObject = {};
  for (let i = 0; i < diaIDs.length; i++) {
    if (!atomLabel || molecule.getAtomLabel(i) === atomLabel) {
      let diaID = diaIDs[i];
      if (!diaIDsObject[diaID]) {
        diaIDsObject[diaID] = {
          counter: 0,
          atoms: [],
          oclID: diaID,
          atomLabel: molecule.getAtomLabel(i),
        };
      }
      diaIDsObject[diaID].counter++;
      diaIDsObject[diaID].atoms.push(i);
    }
  }

  return Object.values(diaIDsObject);
}

/**
 * Check if a specific atom is a sp3 carbon
 * @param {OCL.Molecule} molecule
 * @param {number} atomID
 */

function isCsp3(molecule, atomID) {
  if (molecule.getAtomicNo(atomID) !== 6) return false;
  if (molecule.getAtomCharge(atomID) !== 0) return false;
  if (
    molecule.getImplicitHydrogens(atomID) + molecule.getConnAtoms(atomID) !==
    4
  ) {
    return false;
  }
  return true;
}

const FULL_HOSE_CODE = 1;
const HOSE_CODE_CUT_C_SP3_SP3 = 2;

/**
 * Returns the hose code for a specific atom number
 * @param {OCL.Molecule} originalMolecule
 * @param {array<number>} rootAtoms
 * @param {object} [options={}]
 * @param {boolean} [options.isTagged] Specify is the atoms are already tagged
 * @param {number} [options.minSphereSize=0] Smallest hose code sphere
 * @param {number} [options.maxSphereSize=4] Largest hose code sphere
 * @param {number} [options.kind=FULL_HOSE_CODE] Kind of hose code, default usual sphere
 */
function getHoseCodesForAtoms(
  originalMolecule,
  rootAtoms = [],
  options = {},
) {
  const OCL = originalMolecule.getOCL();
  const {
    minSphereSize = 0,
    maxSphereSize = 4,
    kind = FULL_HOSE_CODE,
    isTagged = false,
  } = options;

  const molecule = originalMolecule.getCompactCopy();

  if (!isTagged) {
    const tags = [];
    for (let i = 0; i < rootAtoms.length; i++) {
      let rootAtom = rootAtoms[i];
      tags.push(tagAtom(molecule, rootAtom));
      molecule.addImplicitHydrogens();
      molecule.addMissingChirality();
      molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);
      // because ensuring helper reorder atoms we need to look again for it
    }
    rootAtoms.length = 0;
    for (let j = 0; j < molecule.getAllAtoms(); j++) {
      if (tags.includes(molecule.getAtomCustomLabel(j))) {
        rootAtoms.push(j);
      }
    }
  }

  let fragment = new OCL.Molecule(0, 0);
  let results = [];
  let min = 0;
  let max = 0;
  let atomMask = new Array(molecule.getAllAtoms());
  let atomList = new Array(molecule.getAllAtoms());

  for (let sphere = 0; sphere <= maxSphereSize; sphere++) {
    if (max === 0) {
      for (let rootAtom of rootAtoms) {
        atomList[max] = rootAtom;
        atomMask[rootAtom] = true;
        max++;
      }
    } else {
      let newMax = max;
      for (let i = min; i < max; i++) {
        let atom = atomList[i];
        for (let j = 0; j < molecule.getAllConnAtoms(atom); j++) {
          let connAtom = molecule.getConnAtom(atom, j);
          if (!atomMask[connAtom]) {
            switch (kind) {
              case FULL_HOSE_CODE:
                atomMask[connAtom] = true;
                atomList[newMax++] = connAtom;
                break;
              case HOSE_CODE_CUT_C_SP3_SP3:
                if (!(isCsp3(molecule, atom) && isCsp3(molecule, connAtom))) {
                  atomMask[connAtom] = true;
                  atomList[newMax++] = connAtom;
                }
                break;
              default:
                throw new Error('getHoseCoesForAtom unknown kind');
            }
          }
        }
      }
      min = max;
      max = newMax;
    }
    molecule.copyMoleculeByAtoms(fragment, atomMask, true, null);
    if (sphere >= minSphereSize) {
      makeRacemic(fragment);
      results.push(
        fragment.getCanonizedIDCode(
          OCL.Molecule.CANONIZER_ENCODE_ATOM_CUSTOM_LABELS,
        ),
      );
    }
  }
  return results;
}

/**
 * Returns the hose code for a specific atom number
 * @param {OCL.Molecule} originalMolecule
 * @param {number} rootAtom
 * @param {object} [options={}]
 * @param {boolean} [options.isTagged] Specify is the atom is already tagged
 * @param {number} [options.minSphereSize=0] Smallest hose code sphere
 * @param {number} [options.maxSphereSize=4] Largest hose code sphere
 * @param {number} [options.kind=FULL_HOSE_CODE] Kind of hose code, default usual sphere
 */
function getHoseCodesForAtom(originalMolecule, rootAtom, options = {}) {
  return getHoseCodesForAtoms(originalMolecule, [rootAtom], options);
}

/**
 * Returns the hose code for a specific marked atom
 * @param {OCL.Molecule} diastereotopicID
 * @param {object} options
 */

function getHoseCodesFromDiastereotopicID(molecule, options = {}) {
  molecule.addImplicitHydrogens();
  molecule.addMissingChirality();

  // One of the atom has to be marked !
  let atomID = -1;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    // we need to find the marked atom
    const atomCustomLabel = molecule.getAtomCustomLabel(i);
    if (atomCustomLabel != null && atomCustomLabel.endsWith('*')) {
      atomID = i;
      break;
    }
  }
  if (atomID >= 0) {
    options.isTagged = true;
    return getHoseCodesForAtom(molecule, atomID, options);
  }
  return undefined;
}

/**
 * Returns an array containing one entry per atom containing
 * diaID and hose code
 * @param {OCL.Molecule} molecule
 * @param {object} options
 */

function getHoseCodesAndDiastereotopicIDs(molecule, options) {
  const diaIDs = getDiastereotopicAtomIDs(molecule).map((oclID) => ({
    oclID,
  }));
  const OCL = molecule.getOCL();
  // TODO: seems like a very slow approach
  diaIDs.forEach((diaID) => {
    const hoses = getHoseCodesFromDiastereotopicID(
      OCL.Molecule.fromIDCode(diaID.oclID),
      options,
    );
    diaID.hoses = [];
    let sphere = 0;
    for (const hose of hoses) {
      diaID.hoses.push({
        sphere: sphere++,
        oclID: hose,
      });
    }
  });
  return diaIDs;
}

let fragment$1;

/**
 * Returns the hose code for a specific atom number
 * @param {OCL.Molecule} molecule
 */
function getHoseCodesForPath(molecule, from, to, maxLength) {
  const OCL = molecule.getOCL();
  const originalFrom = from;
  const originalTo = to;
  molecule = molecule.getCompactCopy();

  let originalAtoms = []; // path before renumbering
  molecule.getPath(originalAtoms, from, to, maxLength + 1);
  let torsion;
  if (originalAtoms.length === 4) {
    torsion = molecule.calculateTorsion(originalAtoms);
  }

  const tag1 = tagAtom(molecule, from);
  const tag2 = tagAtom(molecule, to);

  molecule.addImplicitHydrogens();
  molecule.addMissingChirality();

  molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);

  from = -1;
  to = -1;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (tag1 === tag2) {
      if (molecule.getAtomCustomLabel(i) === tag1) {
        if (from === -1) {
          from = i;
        } else {
          to = i;
        }
      }
    } else {
      if (tag1 === molecule.getAtomCustomLabel(i)) {
        from = i;
      }
      if (tag2 === molecule.getAtomCustomLabel(i)) {
        to = i;
      }
    }
  }

  if (!fragment$1) fragment$1 = new OCL.Molecule(0, 0);

  let atoms = [];
  molecule.getPath(atoms, from, to, maxLength + 1);

  let min = 0;
  let max = 0;
  let atomMask = new Array(molecule.getAllAtoms()).fill(false);
  let atomList = new Array(molecule.getAllAtoms()).fill(-1);
  let hoses = [];

  for (let sphere = 0; sphere <= 2; sphere++) {
    if (max === 0) {
      for (let atom of atoms) {
        atomMask[atom] = true;
        atomList[max++] = atom;
      }
    } else {
      let newMax = max;
      for (let i = min; i < max; i++) {
        let atom = atomList[i];
        for (let j = 0; j < molecule.getAllConnAtoms(atom); j++) {
          let connAtom = molecule.getConnAtom(atom, j);
          if (!atomMask[connAtom]) {
            atomMask[connAtom] = true;
            atomList[newMax++] = connAtom;
          }
        }
      }
      min = max;
      max = newMax;
    }
    let atomMap = [];

    molecule.copyMoleculeByAtoms(fragment$1, atomMask, true, atomMap);
    makeRacemic(fragment$1);
    let oclID = fragment$1.getCanonizedIDCode(
      OCL.Molecule.CANONIZER_ENCODE_ATOM_CUSTOM_LABELS,
    );

    hoses.push({
      sphere,
      oclID,
    });
  }

  return {
    atoms: originalAtoms,
    from: originalFrom,
    to: originalTo,
    torsion,
    hoses,
    length: originalAtoms.length - 1,
  };
}

const MAX_R = 10;

/**
 * Generate molecules and calcule predicted properties form a list of smiles and fragments
 * @param {string} [coreSmiles]
 * @param {array} [fragments] Array of {smiles,R1,R2,...}
 * @param {OCL} [OCL] The openchemlib library
 * @param {object} [options={}]
 * @param {function} [options.onStep] method to execute each new molecules
 * @param {boolean} [options.complexity] returns only the number of molecules to evaluate
 * @return {Promise} promise that resolves to molecules or complexity as a number
 */
async function combineSmiles(coreSmiles, fragments, OCL, options = {}) {
  const { complexity = false } = options;
  const core = getCore(coreSmiles);
  const rGroups = getRGroups(core, fragments);
  if (complexity) {
    return getComplexity(rGroups);
  }
  return generate(core, rGroups, OCL, options);
}

function getComplexity(rGroups) {
  let complexity = 1;
  for (let rGroup of rGroups) {
    complexity *= rGroup.smiles.length;
  }
  return complexity;
}

async function generate(core, rGroups, OCL, options = {}) {
  const { onStep } = options;
  const molecules = {};
  const sizes = new Array(rGroups.length);
  const currents = new Array(rGroups.length);
  for (let i = 0; i < rGroups.length; i++) {
    sizes[i] = rGroups[i].smiles.length - 1;
    currents[i] = 0;
  }
  let position = 0;
  let counter = 0;

  while (true) {
    counter++;
    while (position < currents.length) {
      if (currents[position] < sizes[position]) {
        if (onStep) {
          await onStep(counter);
        }
        appendMolecule(molecules, core, rGroups, currents, OCL);
        currents[position]++;
        for (let i = 0; i < position; i++) {
          currents[i] = 0;
        }
        position = 0;
      } else {
        position++;
      }
    }
    if ((position = currents.length)) {
      if (onStep) {
        await onStep(counter);
      }
      appendMolecule(molecules, core, rGroups, currents, OCL);
      break;
    }
  }
  return Object.keys(molecules)
    .map((key) => molecules[key])
    .sort((m1, m2) => m1.mw - m2.mw);
}

function appendMolecule(molecules, core, rGroups, currents, OCL) {
  let newSmiles = core.smiles;
  for (let i = 0; i < currents.length; i++) {
    newSmiles += `.${rGroups[i].smiles[currents[i]]}`;
  }

  const currentMol = OCL.Molecule.fromSmiles(newSmiles);
  const idCode = currentMol.getIDCode();

  if (!molecules[idCode]) {
    let molecule = {};
    molecules[idCode] = molecule;
    molecule.smiles = currentMol.toSmiles();
    molecule.combinedSmiles = newSmiles;
    molecule.idCode = idCode;
    molecule.molfile = currentMol.toMolfile();

    const props = new OCL.MoleculeProperties(currentMol);
    molecule.nbHAcceptor = props.acceptorCount;
    molecule.nbHDonor = props.donorCount;
    molecule.logP = props.logP;
    molecule.logS = props.logS;
    molecule.PSA = props.polarSurfaceArea;
    molecule.nbRottable = props.rotatableBondCount;
    molecule.nbStereoCenter = props.stereoCenterCount;
    let mf = currentMol.getMolecularFormula();
    molecule.mf = mf.formula;
    molecule.mw = mf.relativeWeight;
  }
}

function getCore(coreSmiles) {
  let core = {
    originalSmiles: coreSmiles,
    smiles: coreSmiles.replace(/\[R(?<group>[1-4])\]/g, '%5$<group>'),
  };

  for (let i = 0; i < MAX_R; i++) {
    if (core.originalSmiles.indexOf(`[R${i}]`) > -1) core[`R${i}`] = true;
  }
  return core;
}

function getRGroups(core, fragments) {
  let rGroups = {};
  for (const fragment of fragments) {
    if (fragment.smiles) {
      const smiles = updateRPosition(fragment.smiles);
      for (let i = 0; i < MAX_R; i++) {
        if (core[`R${i}`]) {
          // we only consider the R that are in the core
          if (fragment[`R${i}`]) {
            if (!rGroups[`R${i}`]) {
              rGroups[`R${i}`] = {
                group: `R${i}`,
                smiles: [],
              };
            }
            rGroups[`R${i}`].smiles.push(smiles.replace(/\[R\]/, `(%5${i})`));
          }
        }
      }
    }
  }
  return Object.keys(rGroups).map((key) => rGroups[key]);
}

function updateRPosition(smiles) {
  // R group should not be at the beginning
  if (smiles.indexOf('[R]') !== 0) return smiles;
  if (smiles.length === 3) return '[H][R]';
  // we are in trouble ... we need to move the R
  let newSmiles = smiles.replace('[R]', '');
  // we need to check where we should put the R group
  let level = 0;
  for (let j = 0; j < newSmiles.length; j++) {
    let currentChar = newSmiles.charAt(j);
    let currentSubstring = newSmiles.substr(j);
    if (currentChar === '(') {
      level++;
    } else if (currentChar === ')') {
      level--;
    } else if (level === 0) {
      if (currentSubstring.match(/^[a-z]/)) {
        return `${newSmiles.substr(0, j + 1)}([R])${newSmiles.substr(j + 1)}`;
      } else if (currentSubstring.match(/^[A-Z][a-z]/)) {
        return `${newSmiles.substr(0, j + 2)}([R])${newSmiles.substr(j + 2)}`;
      } else if (currentSubstring.match(/^[A-Z]/)) {
        return `${newSmiles.substr(0, j + 1)}([R])${newSmiles.substr(j + 1)}`;
      }
    }
  }
  return smiles;
}

/**
 * Returns various information about atoms in the molecule
 * @param {OCL.Molecule} [molecule]
 */
function getAtomsInfo(molecule) {
  const OCL = molecule.getOCL();
  molecule.ensureHelperArrays(OCL.Molecule.cHelperRings);

  let diaIDs = getDiastereotopicAtomIDs(molecule);

  let results = [];
  for (let i = 0; i < diaIDs.length; i++) {
    let result = {
      oclID: diaIDs[i],
      extra: {
        singleBonds: 0,
        doubleBonds: 0,
        tripleBonds: 0,
        aromaticBonds: 0,
        cnoHybridation: 0, // should be 1 (sp), 2 (sp2) or 3 (sp3)
      },
    };
    let extra = result.extra;
    results.push(result);
    result.abnormalValence = molecule.getAtomAbnormalValence(i); // -1 is normal otherwise specified
    result.charge = molecule.getAtomCharge(i);
    result.cipParity = molecule.getAtomCIPParity(i);
    result.color = molecule.getAtomColor(i);
    result.customLabel = molecule.getAtomCustomLabel(i);
    //        result.esrGroup=molecule.getAtomESRGroup(i);
    //        result.esrType=molecule.getAtomESRType(i);
    result.atomicNo = molecule.getAtomicNo(i);
    result.label = molecule.getAtomLabel(i);
    //        result.list=molecule.getAtomList(i);
    //        result.listString=molecule.getAtomListString(i);
    //        result.mapNo=molecule.getAtomMapNo(i);
    result.mass = molecule.getAtomMass(i);
    //        result.parity=molecule.getAtomParity(i);
    //        result.pi=molecule.getAtomPi(i);
    //        result.preferredStereoBond=molecule.getAtomPreferredStereoBond(i);
    //        result.queryFeatures=molecule.getAtomQueryFeatures(i);
    result.radical = molecule.getAtomRadical(i);
    result.ringBondCount = molecule.getAtomRingBondCount(i);
    //        result.ringCount=molecule.getAtomRingCount(i);
    result.ringSize = molecule.getAtomRingSize(i);
    result.x = molecule.getAtomX(i);
    result.y = molecule.getAtomY(i);
    result.z = molecule.getAtomZ(i);
    result.allHydrogens = molecule.getAllHydrogens(i);
    result.connAtoms = molecule.getConnAtoms(i);
    result.allConnAtoms = molecule.getAllConnAtoms(i);

    result.implicitHydrogens =
      result.allHydrogens + result.connAtoms - result.allConnAtoms;

    result.isAromatic = molecule.isAromaticAtom(i);
    result.isAllylic = molecule.isAllylicAtom(i);
    result.isStereoCenter = molecule.isAtomStereoCenter(i);
    result.isRing = molecule.isRingAtom(i);
    result.isSmallRing = molecule.isSmallRingAtom(i);
    result.isStabilized = molecule.isStabilizedAtom(i);

    // todo HACK to circumvent bug in OCL that consider than an hydrogen is connected to itself
    result.extra.singleBonds =
      result.atomicNo === 1 ? 0 : result.implicitHydrogens;
    for (let j = 0; j < molecule.getAllConnAtoms(i); j++) {
      let bond = molecule.getConnBond(i, j);
      let bondOrder = molecule.getBondOrder(bond);
      if (molecule.isAromaticBond(bond)) {
        extra.aromaticBonds++;
      } else if (bondOrder === 1) {
        // not an hydrogen
        extra.singleBonds++;
      } else if (bondOrder === 2) {
        extra.doubleBonds++;
      } else if (bondOrder === 3) {
        extra.tripleBonds++;
      }
    }
    result.extra.totalBonds =
      result.extra.singleBonds +
      result.extra.doubleBonds +
      result.extra.tripleBonds +
      result.extra.aromaticBonds;

    if (result.atomicNo === 6) {
      result.extra.cnoHybridation = result.extra.totalBonds - 1;
    } else if (result.atomicNo === 7) {
      result.extra.cnoHybridation = result.extra.totalBonds;
    } else if (result.atomicNo === 8) {
      result.extra.cnoHybridation = result.extra.totalBonds + 1;
    } else if (result.atomicNo === 1) {
      let connectedAtom =
        molecule.getAllConnAtoms(i) === 0
          ? 0
          : molecule.getAtomicNo(molecule.getConnAtom(i, 0));
      result.extra.hydrogenOnAtomicNo = connectedAtom;
      if (connectedAtom === 7 || connectedAtom === 8) {
        result.extra.labileHydrogen = true;
      }
    }
  }
  return results;
}

/**
 * Returns a connectivity matrix
 * @param {OCL.Molecule} molecule
 * @param {object} [options={}]
 * @param {boolean} [options.pathLength=false] get the path length between atoms
 * @param {boolean} [options.mass=false] set the nominal mass of the atoms on diagonal
 * @param {boolean} [options.atomicNo=false] set the atomic number of the atom on diagonal
 * @param {boolean} [options.negativeAtomicNo=false] set the atomic number * -1 of the atom on diagonal
 * @param {boolean} [options.sdt=false] set 1, 2 or 3 depending if single, double or triple bond
 * @param {boolean} [options.sdta=false] set 1, 2, 3 or 4 depending if single, double, triple or aromatic  bond
 */
function getConnectivityMatrix(molecule, options = {}) {
  const OCL = molecule.getOCL();
  molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);
  let nbAtoms = molecule.getAllAtoms();

  let result = new Array(nbAtoms).fill();
  result = result.map(() => new Array(nbAtoms).fill(0));

  if (!options.pathLength) {
    if (options.atomicNo) {
      for (let i = 0; i < nbAtoms; i++) {
        result[i][i] = molecule.getAtomicNo(i);
      }
    } else if (options.negativeAtomicNo) {
      for (let i = 0; i < nbAtoms; i++) {
        result[i][i] = -molecule.getAtomicNo(i);
      }
    } else if (options.mass) {
      for (let i = 0; i < nbAtoms; i++) {
        result[i][i] = OCL.Molecule.cRoundedMass[molecule.getAtomicNo(i)];
      }
    } else {
      for (let i = 0; i < nbAtoms; i++) {
        result[i][i] = 1;
      }
    }
  }

  if (options.sdt) {
    for (let i = 0; i < nbAtoms; i++) {
      let l = molecule.getAllConnAtoms(i);
      for (let j = 0; j < l; j++) {
        result[i][molecule.getConnAtom(i, j)] = molecule.getConnBondOrder(i, j);
      }
    }
  } else if (options.sdta) {
    for (let i = 0; i < nbAtoms; i++) {
      let l = molecule.getAllConnAtoms(i);
      for (let j = 0; j < l; j++) {
        let bondNumber = molecule.getConnBond(i, j);
        if (molecule.isAromaticBond(bondNumber)) {
          result[i][molecule.getConnAtom(i, j)] = 4;
        } else {
          result[i][molecule.getConnAtom(i, j)] = molecule.getConnBondOrder(
            i,
            j,
          );
        }
      }
    }
  } else {
    for (let i = 0; i < nbAtoms; i++) {
      let l = molecule.getAllConnAtoms(i);
      for (let j = 0; j < l; j++) {
        result[i][molecule.getConnAtom(i, j)] = 1;
      }
    }
  }

  if (options.pathLength) {
    result = floydWarshall__default["default"](new mlMatrix.Matrix(result)).to2DArray();
  }
  return result;
}

/**
 * Calculate the molecular formula in 'chemcalc' notation taking into account fragments, isotopes and charges
 * {OCL.Molecule} [molecule] an instance of OCL.Molecule
 * @returns {object}
 */

function getMF(molecule) {
  let entries = molecule.getFragments();
  let result = {};
  let parts = [];
  let allAtoms = [];

  entries.forEach((entry) => {
    let mf = getFragmentMF(entry, allAtoms);
    parts.push(mf);
  });

  let counts = {};
  for (let part of parts) {
    if (!counts[part]) counts[part] = 0;
    counts[part]++;
  }
  parts = [];
  for (let key of Object.keys(counts).sort()) {
    if (counts[key] > 1) {
      parts.push(counts[key] + key);
    } else {
      parts.push(key);
    }
  }

  result.parts = parts;
  result.mf = toMFString(allAtoms);
  return result;
}

function getFragmentMF(molecule, allAtoms) {
  let atoms = [];
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    let atom = {};
    atom.charge = molecule.getAtomCharge(i);
    atom.label = molecule.getAtomLabel(i);
    atom.mass = molecule.getAtomMass(i);
    atom.implicitHydrogens = molecule.getImplicitHydrogens(i);
    atoms.push(atom);
    allAtoms.push(atom);
  }
  return toMFString(atoms);
}

function toMFString(atoms) {
  let charge = 0;
  let mfs = {};
  for (let atom of atoms) {
    let label = atom.label;
    charge += atom.charge;
    if (atom.mass) {
      label = `[${atom.mass}${label}]`;
    }
    let mfAtom = mfs[label];
    if (!mfAtom) {
      mfs[label] = 0;
    }
    mfs[label] += 1;
    if (atom.implicitHydrogens) {
      if (!mfs.H) mfs.H = 0;
      mfs.H += atom.implicitHydrogens;
    }
  }

  let mf = '';
  let keys = Object.keys(mfs).sort(atomSorter__default["default"]);
  for (let key of keys) {
    mf += key;
    if (mfs[key] > 1) mf += mfs[key];
  }

  if (charge > 0) {
    mf += `(+${charge > 1 ? charge : ''})`;
  } else if (charge < 0) {
    mf += `(${charge < -1 ? charge : '-'})`;
  }
  return mf;
}

/**
 * Return the number of Hydroxyl groups in a molecule or fragment
 * @param {OCL.Molecule} molecule
 * @returns {number} 'Number of Hydroxyl groups'
 */

function nbOH(molecule) {
  let counter = 0;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (molecule.getAtomicNo(i) === 6) {
      let carbonyl = false;
      let hydroxyl = false;
      let carbonOrHydrogen = true;
      for (
        let neighbour = 0;
        neighbour < molecule.getConnAtoms(i);
        neighbour++
      ) {
        const neighbourAtom = molecule.getConnAtom(i, neighbour);

        const neighbourBond = molecule.getConnBond(i, neighbour);
        if (molecule.getAtomicNo(neighbourAtom) === 8) {
          if (
            molecule.getBondOrder(neighbourBond) === 1 &&
            molecule.getAllHydrogens(neighbourAtom) > 0
          ) {
            // If there is more than a Hydroxyl in the same carbon atome they are not couted as Hydroxyl groups
            if (hydroxyl) {
              hydroxyl = false;
              break;
            }
            hydroxyl = true;
          } else if (molecule.getBondOrder(neighbourBond) === 2) {
            // If there is Carbonyl group on the same carbon atom it is not couted as Hydroxyl group
            carbonyl = true;
          }
        } else if (
          // If there is not at least one carbon or hydrogen as neighbour atom it is not counted as Hydroxyl group
          molecule.getAtomicNo(neighbourAtom) !== 6 &&
          molecule.getAtomicNo(neighbourAtom) !== 1
        ) {
          carbonOrHydrogen = false;
        }
      }
      if (carbonyl === false && hydroxyl && carbonOrHydrogen) counter++;
    }
  }

  return counter;
}

/**
 * Return the number of Carboxyl groups in a molecule or fragment
 * @param {OCL.Molecule} molecule
 * @returns {number} 'Number of Carboxyl groups'
 */

function nbCOOH(molecule) {
  let counter = 0;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (molecule.getAtomicNo(i) === 6) {
      let carbonyl = false;
      let hydroxyl = false;
      let carbonOrHydrogen = true;
      for (
        let neighbour = 0;
        neighbour < molecule.getConnAtoms(i);
        neighbour++
      ) {
        const neighbourAtom = molecule.getConnAtom(i, neighbour);

        const neighbourBond = molecule.getConnBond(i, neighbour);
        if (molecule.getAtomicNo(neighbourAtom) === 8) {
          if (
            molecule.getBondOrder(neighbourBond) === 1 &&
            molecule.getAllHydrogens(neighbourAtom) > 0
          ) {
            // If there is more than a Hydroxyl in the same carbon atom it is not couted as Carboxyl group
            if (hydroxyl) {
              hydroxyl = false;
              break;
            }
            hydroxyl = true;
          } else if (molecule.getBondOrder(neighbourBond) === 2) {
            // If there is more than one carbonyl in the same carbon atom it is not count as Carboxyl group
            if (carbonyl) {
              carbonyl = false;
              break;
            }
            carbonyl = true;
          }
        } else if (
          // If there is not at least one carbon or hydrogen as neighbour atom it is not counted as Carboxyl group
          molecule.getAtomicNo(neighbourAtom) !== 6 &&
          molecule.getAtomicNo(neighbourAtom) !== 1
        ) {
          carbonOrHydrogen = false;
        }
      }
      if (carbonyl && hydroxyl && carbonOrHydrogen) counter++;
    }
  }
  return counter;
}

/**
 * Return the number of Carbonyl groups in a molecule or fragment
 * @param {OCL.Molecule} molecule
 * @returns {number} 'Number of Carbonyl groups'
 */

function nbCHO(molecule) {
  let counter = 0;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    // if there is not at least one hydrogen in the carbon atom there can not be a carbonyl group
    if (molecule.getAtomicNo(i) === 6 && molecule.getAllHydrogens(i) > 0) {
      let carbonyl = false;
      let carbonOrHydrogen = true;
      for (
        let neighbour = 0;
        neighbour < molecule.getConnAtoms(i);
        neighbour++
      ) {
        const neighbourAtom = molecule.getConnAtom(i, neighbour);

        const neighbourBond = molecule.getConnBond(i, neighbour);
        if (molecule.getAtomicNo(neighbourAtom) === 8) {
          if (molecule.getBondOrder(neighbourBond) === 2) {
            // If there is more than one carbonyl group on the same carbon atom they are not counted as carbonyl groups
            if (carbonyl) {
              carbonyl = false;
              break;
            }
            carbonyl = true;
          }
        } else if (
          // If there is not at least one carbon or hydrogen as neighbour atom it is not counted as Carbonyl group
          molecule.getAtomicNo(neighbourAtom) !== 6 &&
          molecule.getAtomicNo(neighbourAtom) !== 1
        ) {
          carbonOrHydrogen = false;
        }
      }
      if (carbonyl && carbonOrHydrogen) counter++;
    }
  }

  return counter;
}

/**
 * Return the number of Primary amine groups in a molecule or fragment
 * @param {OCL.Molecule} molecule
 * @returns {number} 'Number of Primary amine groups'
 */

function nbNH2(molecule) {
  let counter = 0;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (molecule.getAtomicNo(i) === 6) {
      let amine = false;
      let carbonOrHydrogen = true;
      for (
        let neighbour = 0;
        neighbour < molecule.getConnAtoms(i);
        neighbour++
      ) {
        const neighbourAtom = molecule.getConnAtom(i, neighbour);

        const neighbourBond = molecule.getConnBond(i, neighbour);

        if (
          molecule.getAtomicNo(neighbourAtom) === 7 &&
          molecule.getBondOrder(neighbourBond) === 1 &&
          molecule.getAllHydrogens(neighbourAtom) > 1
        ) {
          // If there is more than a Primary amine in the same carbon atom they are not couted as Primary amines groups
          if (amine) {
            amine = false;
            break;
          }
          amine = true;
        } else if (
          // If there is not at least one carbon or hydrogen as neighbour atom it is not counted as Primary amine group
          molecule.getAtomicNo(neighbourAtom) !== 6 &&
          molecule.getAtomicNo(neighbourAtom) !== 1
        ) {
          carbonOrHydrogen = false;
        }
      }
      if (amine && carbonOrHydrogen) counter++;
    }
  }

  return counter;
}

/**
 * Return the number of Nitrile groups in a molecule or fragment
 * @param {OCL.Molecule} molecule
 * @returns {number} 'Number of Nitrile groups'
 */

function nbCN(molecule) {
  let counter = 0;
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    if (molecule.getAtomicNo(i) === 6) {
      let cn = false;
      let carbonOrHydrogen = true;
      for (
        let neighbour = 0;
        neighbour < molecule.getConnAtoms(i);
        neighbour++
      ) {
        const neighbourAtom = molecule.getConnAtom(i, neighbour);

        const neighbourBond = molecule.getConnBond(i, neighbour);

        if (
          molecule.getAtomicNo(neighbourAtom) === 7 &&
          molecule.getBondOrder(neighbourBond) === 3
        ) {
          // If there is more than one Nitrile group in the same carbon atome they are not counted as Nitrile groups
          if (cn) {
            cn = false;
            break;
          }
          cn = true;
        } else if (
          // If there is not at least one carbon or hydrogen as neighbour atom it is not counted as Nitrile group
          molecule.getAtomicNo(neighbourAtom) !== 6 &&
          molecule.getAtomicNo(neighbourAtom) !== 1
        ) {
          carbonOrHydrogen = false;
        }
      }

      if (cn && carbonOrHydrogen) counter++;
    }
  }

  return counter;
}

let fragment;

/**
 *
 * @param {OCL.Molecule} molecule
 * @param {object} [options={}]
 * @param {string} [opions.fromLabel='H']
 * @param {string} [opions.toLabel='H']
 * @param {string} [opions.minLength=1]
 * @param {string} [opions.maxLength=4]

 */
function getPathsInfo(molecule, options = {}) {
  const {
    fromLabel = 'H',
    toLabel = 'H',
    minLength = 1,
    maxLength = 4,
  } = options;

  const OCL = molecule.getOCL();

  if (!fragment) {
    fragment = new OCL.Molecule(0, 0);
  }

  let fromAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(fromLabel);
  let toAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(toLabel);

  // we need to find all the atoms 'fromLabel' and 'toLabel'
  let atomsInfo = getAtomsInfo(molecule);

  let pathLengthMatrix = getConnectivityMatrix(molecule, {
    pathLength: true,
  });

  for (let from = 0; from < molecule.getAllAtoms(); from++) {
    atomsInfo[from].paths = [];
    for (let to = 0; to < molecule.getAllAtoms(); to++) {
      if (from !== to) {
        if (molecule.getAtomicNo(from) === fromAtomicNumber) {
          if (molecule.getAtomicNo(to) === toAtomicNumber) {
            let pathLength = pathLengthMatrix[from][to];
            if (pathLength >= minLength && pathLength <= maxLength) {
              atomsInfo[from].paths.push(
                getHoseCodesForPath(
                  molecule,
                  from,
                  to,
                  pathLength,
                  atomsInfo[to].oclID,
                ),
              );
            }
          }
        }
      }
    }
  }

  return atomsInfo;
}

/**
 * Get the shortest path between each pair of atoms in the molecule
 * @param {OCL.Molecule} molecule
 * @param {object} [options={}]
 * @param {string} [opions.fromLabel='H']
 * @param {string} [opions.toLabel='H']
 * @param {string} [opions.maxLength=4]
 * @returns {Array<Array>} A matrix containing on each cell (i,j) the shortest path from atom i to atom j
 */
function getShortestPaths(molecule, options = {}) {
  const OCL = molecule.getOCL();
  const { fromLabel = '', toLabel = '', maxLength = 3 } = options;

  let fromAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(fromLabel);
  let toAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(toLabel);

  const nbAtoms = molecule.getAllAtoms();
  let allShortestPaths = new Array(nbAtoms);
  for (let i = 0; i < nbAtoms; i++) {
    allShortestPaths[i] = new Array(nbAtoms);
  }

  for (let from = 0; from < nbAtoms; from++) {
    allShortestPaths[from][from] = [from];
    for (let to = from + 1; to < nbAtoms; to++) {
      if (
        (fromAtomicNumber === 0 ||
          molecule.getAtomicNo(from) === fromAtomicNumber) &&
        (toAtomicNumber === 0 || molecule.getAtomicNo(to) === toAtomicNumber)
      ) {
        let path = [];
        molecule.getPath(path, from, to, maxLength);
        if (path.length) {
          allShortestPaths[from][to] = path.slice();
          allShortestPaths[to][from] = path.reverse();
        } else {
          allShortestPaths[from][to] = null;
          allShortestPaths[to][from] = null;
        }
      } else {
        allShortestPaths[from][to] = null;
        allShortestPaths[to][from] = null;
      }
    }
  }

  return allShortestPaths;
}

function getMoleculeCreators(Molecule) {
  const fields = new Map();

  fields.set('oclid', Molecule.fromIDCode);
  fields.set('idcode', Molecule.fromIDCode);
  fields.set('smiles', Molecule.fromSmiles);
  fields.set('molfile', Molecule.fromMolfile);

  return fields;
}

const defaultCSVOptions = {
  header: true,
  dynamicTyping: true,
  skipEmptyLines: true,
};

async function appendCSV(moleculesDB, csv, options = {}) {
  const { onStep } = options;
  csv = ensureString.ensureString(csv);
  const moleculeCreators = getMoleculeCreators(moleculesDB.OCL.Molecule);

  if (typeof csv !== 'string') {
    throw new TypeError('csv must be a string');
  }
  options = { ...defaultCSVOptions, ...options };

  const parsed = Papa__default["default"].parse(csv, options);
  const fields = parsed.meta.fields;
  const stats = new Array(fields.length);
  const firstElement = parsed.data[0];
  let moleculeCreator, moleculeField;
  for (let i = 0; i < fields.length; i++) {
    stats[i] = {
      label: fields[i],
      isNumeric: typeof firstElement[fields[i]] === 'number',
    };
    const lowerField = fields[i].toLowerCase();
    if (moleculeCreators.has(lowerField)) {
      moleculeCreator = moleculeCreators.get(lowerField);
      moleculeField = fields[i];
    }
  }
  if (!moleculeCreator) {
    throw new Error('this document does not contain any molecule field');
  }
  moleculesDB.statistics = stats;

  for (let i = 0; i < parsed.data.length; i++) {
    moleculesDB.pushEntry(
      moleculeCreator(parsed.data[i][moleculeField]),
      parsed.data[i],
    );
    if (onStep) {
      await onStep(i + 1, parsed.data.length);
    }
  }
}

function appendColor(moleculesDB, options = {}) {
  const {
    dataLabel,
    propertyLabel,
    minValue,
    maxValue,
    minHue = 0,
    maxHue = 360,
    saturation = 65,
    lightness = 65,
    colorLabel = 'color',
  } = options;

  const db = moleculesDB.getDB();
  let values;
  if (dataLabel) {
    values = db
      .map((result) =>
        result.data.map((datum) => ({ value: datum[dataLabel], data: datum })),
      )
      .flat();
  } else if (propertyLabel) {
    values = db
      .map((result) =>
        result.data.map((datum) => ({
          value: result.properties[propertyLabel],
          data: datum,
        })),
      )
      .flat();
  } else {
    values = db
      .map((result) =>
        result.data.map((datum) => ({ value: undefined, data: datum })),
      )
      .flat();
  }

  if (minValue !== undefined) {
    values = values.forEach((value) => {
      if (value.value !== undefined && value.value < minValue) {
        value.value = minValue;
      }
    });
  }

  if (maxValue !== undefined) {
    values = values.forEach((value) => {
      if (value.value !== undefined && value.value > maxValue) {
        value.value = maxValue;
      }
    });
  }

  const definedValues = values.filter((value) => value.value !== undefined);
  const min = Math.min(...definedValues.map((value) => value.value));
  const max = Math.max(...definedValues.map((value) => value.value));

  for (let value of values) {
    if (value.value !== undefined) {
      value.data[colorLabel] =
        `hsl(${
        Math.floor(
          ((value.value - min) / (max - min)) * (maxHue - minHue) + minHue,
        )
        },${
        saturation
        }%,${
        lightness
        }%)`;
    } else {
      value.data.color = 'black';
    }
  }
}

async function appendSDF(moleculesDB, sdf, options = {}) {
  const { onStep } = options;
  sdf = ensureString.ensureString(sdf);
  if (typeof sdf !== 'string') {
    throw new TypeError('sdf must be a string');
  }
  const parsed = sdfParser.parse(sdf);
  moleculesDB.statistics = parsed.statistics;
  for (let i = 0; i < parsed.molecules.length; i++) {
    const molecule = parsed.molecules[i];
    moleculesDB.pushEntry(
      moleculesDB.OCL.Molecule.fromMolfile(molecule.molfile),
      molecule,
    );
    if (onStep) {
      await onStep(i + 1, parsed.molecules.length);
    }
  }
}

async function appendSmilesList(
  moleculesDB,
  text,
  options = {},
) {
  const { onStep } = options;
  text = ensureString.ensureString(text);
  if (typeof text !== 'string') {
    throw new TypeError('text must be a string');
  }
  const smilesArray = text
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line);
  for (let i = 0; i < smilesArray.length; i++) {
    const oneSmiles = smilesArray[i];
    moleculesDB.pushEntry(moleculesDB.OCL.Molecule.fromSmiles(oneSmiles));
    if (onStep) {
      await onStep(i + 1, smilesArray.length);
    }
  }
}

function pushEntry(
  moleculesDB,
  molecule,
  data = {},
  moleculeInfo = {},
) {
  // the following line could be the source of problems if the idCode version
  // changes

  let moleculeIDCode = moleculeInfo.idCode
    ? moleculeInfo.idCode
    : molecule.getIDCode();
  let entry = moleculesDB.db[moleculeIDCode];
  if (!entry) {
    // a new molecule
    entry = { molecule, properties: {}, data: [], idCode: moleculeIDCode };
    moleculesDB.db[moleculeIDCode] = entry;

    // ensure helper arrays needed for substructure search
    molecule.ensureHelperArrays(moleculesDB.OCL.Molecule.cHelperRings);
    if (!moleculeInfo.index) {
      entry.index = molecule.getIndex();
    } else {
      entry.index = moleculeInfo.index;
    }

    let molecularFormula;
    if (!moleculeInfo.mw) {
      molecularFormula = molecule.getMolecularFormula();
      entry.properties.mw = molecularFormula.relativeWeight;
    } else {
      entry.properties.mw = moleculeInfo.mw;
    }

    if (moleculesDB.computeProperties) {
      if (!molecularFormula) {
        molecularFormula = molecule.getMolecularFormula();
      }
      const properties = new moleculesDB.OCL.MoleculeProperties(molecule);
      entry.properties.em = molecularFormula.absoluteWeight;
      entry.properties.mf = molecularFormula.formula;
      entry.properties.acceptorCount = properties.acceptorCount;
      entry.properties.donorCount = properties.donorCount;
      entry.properties.logP = properties.logP;
      entry.properties.logS = properties.logS;
      entry.properties.polarSurfaceArea = properties.polarSurfaceArea;
      entry.properties.rotatableBondCount = properties.rotatableBondCount;
      entry.properties.stereoCenterCount = properties.stereoCenterCount;
    }
  }
  entry.data.push(data);
}

function pushMoleculeInfo(moleculesDB, moleculeInfo, data = {}) {
  if (typeof moleculeInfo !== 'object') {
    throw new Error('pushMoleculeInfo requires an object as first parameter');
  }
  const Molecule = moleculesDB.OCL.Molecule;
  let molecule;
  if (moleculeInfo.molfile) {
    molecule = Molecule.fromMolfile(moleculeInfo.molfile);
  }
  if (moleculeInfo.smiles) molecule = Molecule.fromSmiles(moleculeInfo.smiles);
  if (moleculeInfo.idCode) {
    if (moleculesDB.db[moleculeInfo.idCode]) {
      molecule = moleculesDB.db[moleculeInfo.idCode].molecule;
    } else {
      molecule = Molecule.fromIDCode(
        moleculeInfo.idCode,
        moleculeInfo.coordinates || false,
      );
    }
  }

  if (molecule) {
    moleculesDB.pushEntry(molecule, data, moleculeInfo);
  }
}

function search(moleculesDB, query, options = {}) {
  const {
    format = 'idCode',
    mode = 'substructure',
    flattenResult = true,
    keepMolecule = false,
    limit = Number.MAX_SAFE_INTEGER,
  } = options;

  if (typeof query === 'string') {
    const moleculeCreators = getMoleculeCreators(moleculesDB.OCL.Molecule);
    query = moleculeCreators.get(format.toLowerCase())(query);
  } else if (!(query instanceof moleculesDB.OCL.Molecule)) {
    throw new TypeError('toSearch must be a Molecule or string');
  }

  let result;
  switch (mode.toLowerCase()) {
    case 'exact':
      result = exactSearch(moleculesDB, query);
      break;
    case 'substructure':
      result = subStructureSearch(moleculesDB, query);
      break;
    case 'similarity':
      result = similaritySearch(moleculesDB, query);
      break;
    default:
      throw new Error(`unknown search mode: ${options.mode}`);
  }
  return processResult(result, { flattenResult, keepMolecule, limit });
}

function exactSearch(moleculesDB, query) {
  const queryIDCode = query.getIDCode();
  let searchResult = moleculesDB.db[queryIDCode]
    ? [moleculesDB.db[queryIDCode]]
    : [];
  return searchResult;
}

function subStructureSearch(moleculesDB, query) {
  let resetFragment = false;
  if (!query.isFragment()) {
    resetFragment = true;
    query.setFragment(true);
  }

  const queryMW = getMW(query);
  const searchResult = [];
  if (query.getAllAtoms() === 0) {
    for (let idCode in moleculesDB.db) {
      searchResult.push(moleculesDB.db[idCode]);
    }
  } else {
    const queryIndex = query.getIndex();
    const searcher = moleculesDB.searcher;

    searcher.setFragment(query, queryIndex);
    for (let idCode in moleculesDB.db) {
      let entry = moleculesDB.db[idCode];
      searcher.setMolecule(entry.molecule, entry.index);
      if (searcher.isFragmentInMolecule()) {
        searchResult.push(entry);
      }
    }
  }

  searchResult.sort((a, b) => {
    return (
      Math.abs(queryMW - a.properties.mw) - Math.abs(queryMW - b.properties.mw)
    );
  });

  if (resetFragment) {
    query.setFragment(false);
  }

  return searchResult;
}

function similaritySearch(moleculesDB, query) {
  const queryIndex = query.getIndex();
  const queryMW = getMW(query);
  const queryIdCode = query.getIDCode();

  const searchResult = [];
  let similarity;
  for (let idCode in moleculesDB.db) {
    let entry = moleculesDB.db[idCode];
    if (entry.idCode === queryIdCode) {
      similarity = Number.MAX_SAFE_INTEGER;
    } else {
      similarity =
        moleculesDB.OCL.SSSearcherWithIndex.getSimilarityTanimoto(
          queryIndex,
          entry.index,
        ) *
          1000000 -
        Math.abs(queryMW - entry.properties.mw) / 10000;
    }
    searchResult.push({ similarity, entry });
  }
  searchResult.sort((a, b) => {
    return b.similarity - a.similarity;
  });
  return searchResult.map((entry) => entry.entry);
}

function getMW(query) {
  let copy = query.getCompactCopy();
  copy.setFragment(false);
  return copy.getMolecularFormula().relativeWeight;
}

function processResult(entries, options = {}) {
  const {
    flattenResult = true,
    keepMolecule = false,
    limit = Number.MAX_SAFE_INTEGER,
  } = options;
  let results = [];

  if (flattenResult) {
    for (let entry of entries) {
      for (let data of entry.data) {
        results.push({
          data,
          idCode: entry.idCode,
          properties: entry.properties,
          molecule: keepMolecule ? entry.molecule : undefined,
        });
      }
    }
  } else {
    for (let entry of entries) {
      results.push({
        data: entry.data,
        idCode: entry.idCode,
        properties: entry.properties,
        molecule: keepMolecule ? entry.molecule : undefined,
      });
    }
  }
  if (limit < results.length) results.length = limit;
  return results;
}

/*
    this.db is an object with properties 'oclID' that has as value
    an object that contains the following properties:
    * molecule: an OCL molecule instance
    * index: OCL index used for substructure searching
    * properties: all the calculates properties
    * data: array containing free data associated with this molecule
  */

class MoleculesDB {
  /**
   *
   * @param {OCL} [OCL] The openchemlib library
   * @param {object} [options={}]
   * @param {boolean} [options.computeProperties=false]
   */
  constructor(OCL, options = {}) {
    const { computeProperties = false } = options;
    this.OCL = OCL;
    this.db = {};
    this.statistics = null;
    this.computeProperties = computeProperties;
    this.searcher = new OCL.SSSearcherWithIndex();
  }

  /**
   * append to the current database a CSV file
   * @param {string|ArrayBuffer} csv - text file containing the comma separated value file
   * @param {object} [options={}]
   * @param {boolean} [options.header=true]
   * @param {boolean} [options.dynamicTyping=true]
   * @param {boolean} [options.skipEmptyLines=true]
   * @param {function} [options.onStep] call back to execute after each molecule
   */

  appendCSV(csv, options) {
    return appendCSV(this, csv, {
      computeProperties: this.computeProperties,
      ...options,
    });
  }

  /**
   * Append a SDF to the current database
   * @param {string|ArrayBuffer} sdf - text file containing the sdf
   * @param {object} [options={}]
   * @param {function} [options.onStep] call back to execute after each molecule
   * @returns {DB}
   */

  appendSDF(sdf, options) {
    return appendSDF(this, sdf, {
      computeProperties: this.computeProperties,
      ...options,
    });
  }

  /**
   * Append a SDF to the current database
   * @param {string|ArrayBuffer} smiles - text file containing a list of smiles
   * @param {object} [options={}]
   * @param {function} [options.onStep] call back to execute after each molecule
   * @returns {DB}
   */

  appendSmilesList(text, options) {
    return appendSmilesList(this, text, {
      computeProperties: this.computeProperties,
      ...options,
    });
  }

  /**
   * Add a molecule to the current database
   * @param {OCL.Molecule} molecule
   * @param {object} [data={}]
   * @param {object} [moleculeInfo={}] may contain precalculated index and mw
   */

  pushEntry(molecule, data, moleculeInfo) {
    pushEntry(this, molecule, data, moleculeInfo);
  }

  /**
   * Add an entry in the database
   * @param {object} moleculeInfo - a molecule as a JSON that may contain the following properties: molfile, smiles, idCode, mf, index
   * @param {object} [data={}]
   */

  pushMoleculeInfo(moleculeInfo, data) {
    return pushMoleculeInfo(this, moleculeInfo, data);
  }

  /**
   * Search in a MoleculesDB
   * Inside the database all the same molecules are group together
   * @param {string|OCL.Molecule} [query] smiles, molfile, oclCode or instance of Molecule to look for
   * @param {object} [options={}]
   * @param {string} [options.format='idCode'] - query is in the format 'smiles', 'oclid' or 'molfile'
   * @param {string} [options.mode='substructure'] - search by 'substructure', 'exact' or 'similarity'
   * @param {boolean} [options.flattenResult=true] - The database group the data for the same product. This allows to flatten the result
   * @param {boolean} [options.keepMolecule=false] - keep the OCL.Molecule object in the result
   * @param {number} [options.limit=Number.MAX_SAFE_INTEGER] - maximal number of result
   * @return {Array} array of object of the type {(molecule), idCode, data, properties}
   */
  search(query, options) {
    return search(this, query, options);
  }

  /**
   * Returns an array with the current database
   * @returns
   */
  getDB() {
    return Object.keys(this.db).map((key) => this.db[key]);
  }

  /**
   * Append the property `data.color` to each entry based on a data or property label
   * {object} [options={}]
   * {string} [options.dataLabel] name of the property from `data` to use
   * {string} [options.propertyLabel] name of the property from `properties` to use
   * {number} [options.colorLabel='color'] name of the property to add in data that will contain the color
   * {number} [options.minValue]
   * {number} [options.maxValue]
   * {number} [options.minHue=0]
   * {number} [options.maxHue=360]
   * {number} [options.saturation=65] percent of color saturation
   * {number} [options.lightness=65] percent of color lightness
   */
  appendColor(options) {
    appendColor(this, options);
  }
}

function toVisualizerMolfile(molecule, options = {}) {
  const { diastereotopic, heavyAtomHydrogen } = options;

  let highlight = [];
  let atoms = {};
  if (diastereotopic) {
    let hydrogenInfo = {};
    let extendedIDs = getDiastereotopicAtomIDsAndH(molecule);
    for (let line of extendedIDs) {
      hydrogenInfo[line.oclID] = line;
    }

    let diaIDs = getGroupedDiastereotopicAtomIDs(molecule);
    for (const diaID of diaIDs) {
      atoms[diaID.oclID] = diaID.atoms;
      highlight.push(diaID.oclID);
      if (heavyAtomHydrogen) {
        if (
          hydrogenInfo[diaID.oclID] &&
          hydrogenInfo[diaID.oclID].nbHydrogens > 0
        ) {
          for (let id of hydrogenInfo[diaID.oclID].hydrogenOCLIDs) {
            highlight.push(id);
            atoms[id] = diaID.atoms;
          }
        }
      }
    }
  } else {
    let size = molecule.getAllAtoms();
    highlight = new Array(size).fill(0).map((a, index) => index);
    atoms = highlight.map((a) => [a]);
  }

  let molfile = {
    type: 'mol2d',
    value: molecule.toMolfile(),
    _highlight: highlight,
    _atoms: atoms,
  };

  return molfile;
}

function fragmentAcyclicSingleBonds(molecule) {
  const OCL = molecule.getOCL();
  let atoms = [];
  for (let i = 0; i < molecule.getAllAtoms(); i++) {
    let atom = {};
    atoms.push(atom);
    atom.i = i;
    atom.links = []; // we will store connected atoms of broken bonds
  }

  let bonds = [];
  for (let i = 0; i < molecule.getAllBonds(); i++) {
    let bond = {};
    bonds.push(bond);
    bond.i = i;
    bond.order = molecule.getBondOrder(i);
    bond.atom1 = molecule.getBondAtom(0, i);
    bond.atom2 = molecule.getBondAtom(1, i);
    bond.type = molecule.getBondType(i);
    bond.isAromatic = molecule.isAromaticBond(i);
    bond.isRingBond = molecule.isRingBond(i);
    if (!bond.isAromatic && (bond.type & 0b11) === 1 && !bond.isRingBond) {
      bond.selected = true;
      atoms[bond.atom1].links.push(bond.atom2);
      atoms[bond.atom2].links.push(bond.atom1);
    }
  }

  //  console.log(bonds);

  let brokenMolecule = molecule.getCompactCopy();
  for (let bond of bonds) {
    if (bond.selected) {
      brokenMolecule.markBondForDeletion(bond.i);
    }
  }

  brokenMolecule.deleteMarkedAtomsAndBonds();
  let fragmentMap = [];
  let nbFragments = brokenMolecule.getFragmentNumbers(fragmentMap);
  let results = [];
  for (let i = 0; i < nbFragments; i++) {
    let result = {};
    result.atomMap = [];
    let includeAtom = fragmentMap.map((id) => {
      return id === i;
    });
    let fragment = new OCL.Molecule(0, 0);
    let atomMap = [];
    brokenMolecule.copyMoleculeByAtoms(fragment, includeAtom, false, atomMap);
    // we will add some R groups at the level of the broken bonds
    for (let j = 0; j < atomMap.length; j++) {
      if (atomMap[j] > -1) {
        result.atomMap.push(j);
        if (atoms[j].links.length > 0) {
          for (let k = 0; k < atoms[j].links.length; k++) {
            fragment.addBond(atomMap[j], fragment.addAtom(154), 1);
          }
        }
      }
    }
    fragment.setFragment(false);
    result.idCode = fragment.getIDCode();
    result.mf = getMF(fragment).mf.replace(/R[1-9]?/, '');
    results.push(result);
  }

  return results;
}

exports.FULL_HOSE_CODE = FULL_HOSE_CODE;
exports.HOSE_CODE_CUT_C_SP3_SP3 = HOSE_CODE_CUT_C_SP3_SP3;
exports.MoleculesDB = MoleculesDB;
exports.addDiastereotopicMissingChirality = addDiastereotopicMissingChirality;
exports.combineSmiles = combineSmiles;
exports.fragmentAcyclicSingleBonds = fragmentAcyclicSingleBonds;
exports.getAtomsInfo = getAtomsInfo;
exports.getConnectivityMatrix = getConnectivityMatrix;
exports.getDiastereotopicAtomIDs = getDiastereotopicAtomIDs;
exports.getDiastereotopicAtomIDsAndH = getDiastereotopicAtomIDsAndH;
exports.getGroupedDiastereotopicAtomIDs = getGroupedDiastereotopicAtomIDs;
exports.getHoseCodesAndDiastereotopicIDs = getHoseCodesAndDiastereotopicIDs;
exports.getHoseCodesForAtom = getHoseCodesForAtom;
exports.getHoseCodesForAtoms = getHoseCodesForAtoms;
exports.getHoseCodesForPath = getHoseCodesForPath;
exports.getHoseCodesFromDiastereotopicID = getHoseCodesFromDiastereotopicID;
exports.getMF = getMF;
exports.getPathsInfo = getPathsInfo;
exports.getShortestPaths = getShortestPaths;
exports.isCsp3 = isCsp3;
exports.makeRacemic = makeRacemic;
exports.nbCHO = nbCHO;
exports.nbCN = nbCN;
exports.nbCOOH = nbCOOH;
exports.nbNH2 = nbNH2;
exports.nbOH = nbOH;
exports.tagAtom = tagAtom;
exports.toDiastereotopicSVG = toDiastereotopicSVG;
exports.toVisualizerMolfile = toVisualizerMolfile;
