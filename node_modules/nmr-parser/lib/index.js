'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var isAnyArray = require('is-any-array');
var jeolconverter = require('jeolconverter');
var nmrProcessing = require('nmr-processing');
var brukerconverter = require('brukerconverter');
var jcampconverter = require('jcampconverter');

/**
 * a number that correspond to a type of numeric
 * @typedef {number} numericType
 * @const
 */
const numericTypeTable = {
  0: 'uint8',
  1: 'uint16',
  2: 'uint32',
  3: 'uint64',
  4: 'int8',
  5: 'int16',
  6: 'int32',
  7: 'int64',
  8: 'float32',
  9: 'float64',
  10: 'complex64',
  11: 'complex128',
};

/**
 * a number that corresponds to a type of quantity
 * @typedef {number} quantityType
 * @const
 */
const quantityTypeTable = {
  0: 'scalar',
  1: 'vector',
  2: 'matrix',
  3: 'symetricMatrix',
  4: 'pixel',
};

/**
 * a class for dependent variable
 * @param {object || array} data - the dependent variable
 * @param {numericType} numericType - a number that correspond to a type of numeric used to store the components
 * @param {object} [options] - an object with options (name, unit, quantityName, componentLabels, sparseSampling, application, description)
 * @param {string} [options.name] - a name of the dependent variable
 * @param {string} [options.unit] - the unit of the dependent variable
 * @param {string} [options.quantityName] - a name of the quantity
 * @param {array} [options.componentLabels] - an array of labels for each component of the dependent variable
 * @return {object} - an dependent variable
 */
function formatDependentVariable(data, numericType, options = {}) {
  let {
    quantityType = 0,
    encoding = 'none',
    name = '',
    unit = '',
    quantityName = '',
    componentLabels = [],
    sparseSampling = {},
    from = 0,
    to = -1,
  } = options;

  let components;
  if (isAnyArray.isAnyArray(data)) {
    throw new Error('not yet implemented');
  } else if (Object.keys(data).length === 2) {
    components = fromReIm(data, from, to);
  }

  if (componentLabels.length === 0) {
    componentLabels = components.componentLabels;
  }

  return {
    type: 'internal',
    quantityType: quantityTypeTable[quantityType],
    numericType: numericTypeTable[numericType],
    encoding,
    name,
    unit,
    quantityName,
    componentLabels,
    sparseSampling,
    description: options.description || '',
    application: options.application || '',
    components: components.components,
    dataLength: components.dataLength,
  };
}

/**
 * import object {re:[], im:[]} to component
 * @param {object} reIm - a reIm object to import
 * @param {number} from - lower limit
 * @param {number} to - upper limit
 * @return {array} - components
 */
function fromReIm(reIm, from, to) {
  let dataLength = [];
  let componentLabels = [];
  let components = [];
  if (isAnyArray.isAnyArray(reIm.re) & isAnyArray.isAnyArray(reIm.im)) {
    if (typeof reIm.re[0] === 'number') {
      // if 1D
      dataLength[0] = setLengthComplex(from[0], to[0], reIm.re.length);
      let component = new Float64Array(dataLength[0]);
      for (let i = 0; i < dataLength[0]; i += 2) {
        let idx = i + from[0] * 2;
        component[i] = reIm.re[idx / 2];
        component[i + 1] = reIm.im[idx / 2];
      }
      components.push(component);
      componentLabels.push('complex');
    } else if (isAnyArray.isAnyArray(reIm.re[0])) {
      // if 2D
      dataLength[0] = setLength(from[1], to[1], reIm.re.length);
      dataLength[1] = setLengthComplex(from[0], to[0], reIm.re[0].length);

      for (let j = 0; j < dataLength[0]; j++) {
        let component = new Float64Array(dataLength[1]);
        for (let i = 0; i < dataLength[1]; i += 2) {
          let idx = i + from[0] * 2;
          component[i] = reIm.re[j][idx / 2];
          component[i + 1] = reIm.im[j][idx / 2];
        }
        components.push(component);
      }
    } else {
      throw new Error('check your object');
    }
  } else if (isAnyArray.isAnyArray(reIm.re.re)) {
    dataLength[0] = reIm.re.re.length * 2;
    let re = fromReIm(reIm.re, from, to).components;
    let im = fromReIm(reIm.im, from, to).components;
    for (let j = 0; j < dataLength[0] / 2; j++) {
      components.push(re[j]);
      components.push(im[j]);
    }
  } else {
    throw new Error('check the dimension or the type of data in your array');
  }

  return {
    dataLength,
    componentLabels,
    components,
  };
}

function setLength(from, to, length) {
  if (to - from + 1 < length) {
    return to - from + 1;
  } else {
    return length;
  }
}

function setLengthComplex(from, to, length) {
  if (to - from + 1 < length) {
    return (to - from + 1) * 2;
  } else {
    return length * 2;
  }
}

// /**
//  * add component to components from 1D array.
//  * @param {array} array - a 1D or 2D array to import
//  * @return {Float64Array} - component
//  */
// function add1DArray(array) {
//   let component;
//   component = new Float64Array(array.length);
//   for (let i = 0; i < array.length; i++) {
//     component[i] = array[i];
//   }
//   return component;
// }

// /**
//  * import component to InternalDEPENDENTVAR class object from 1D or 2D array.
//  * @param {array} array - a 1D or 2D array to import
//  */
// function fromArray(array) {
//   this.dataLength[0] = array.length;
//   if (typeof array[0] === 'number') {
//     this.components = [this.add1DArray(array)];
//   } else if (Array.isArray(array[0])) {
//     this.dataLength[1] = array[0].length;
//     for (let j = 0; j < this.dataLength[1]; j++) {
//       this.components.push(this.add1DArray(array[j]));
//     }
//   } else {
//     throw new Error('check the dimension or the type of data in your array');
//   }
//   return this;
// }

/**
 *
 * @param {*} label
 * @param {*} count
 * @param {*} increment
 * @param {*} options
 */
function formatLinearDimension(label, count, increment, options = {}) {
  return {
    label: String(label),
    count: Number(count),
    increment: increment,
    type: 'linear',
    description: String(options.description) || '',
    application: options.application || {},
    coordinatesOffset: options.coordinatesOffset || 0,
    originOffset: options.originOffset || 0,
    quantityName: String(options.quantityName) || '',
    reciprocal: options.reciprocal || {},
    period: options.period || 0,
    complexFFT: options.complexFFT || false,
  };
}

var name = "nmr-parser";
var version = "1.7.3";
var description = "Read and convert any NMR file";
var main = "lib/index.js";
var module$1 = "src/index.js";
var files = [
	"lib",
	"src"
];
var scripts = {
	eslint: "eslint src",
	"eslint-fix": "npm run eslint -- --fix",
	compile: "rollup -c",
	prepublishOnly: "npm run compile",
	test: "npm run compile && npm run test-coverage && npm run eslint",
	"test-coverage": "jest --coverage",
	"test-only": "jest",
	build: "cheminfo-build --entry src/index.js --root NMRparser"
};
var repository = {
	type: "git",
	url: "git+https://github.com/cheminfo/nmr-parser.git"
};
var keywords = [
	"nmr",
	"magnetic resonance",
	"parser",
	"bruker",
	"JEOL",
	"CSDM",
	"data analysis"
];
var author = "Julien Wist";
var license = "MIT";
var bugs = {
	url: "https://github.com/cheminfo/nmr-parser/issues"
};
var homepage = "https://github.com/cheminfo/nmr-parser#readme";
var jest = {
	testEnvironment: "node"
};
var prettier = {
	arrowParens: "always",
	semi: true,
	singleQuote: true,
	tabWidth: 2,
	trailingComma: "all"
};
var devDependencies = {
	"@babel/plugin-transform-modules-commonjs": "^7.16.8",
	"@rollup/plugin-json": "^4.1.0",
	"@types/jest": "^27.4.1",
	"bruker-data-test": "^0.1.0",
	"cheminfo-build": "^1.1.11",
	eslint: "^8.9.0",
	"eslint-config-cheminfo": "^7.2.2",
	"jcamp-data-test": "^0.0.5",
	"jeol-data-test": "^0.2.3",
	jest: "^27.5.1",
	prettier: "^2.5.1",
	rollup: "^2.68.0"
};
var dependencies = {
	brukerconverter: "^3.5.0",
	"is-any-array": "^2.0.0",
	jcampconverter: "^8.2.5",
	jeolconverter: "^1.0.1",
	"nmr-processing": "^7.0.1"
};
var packageJson = {
	name: name,
	version: version,
	description: description,
	main: main,
	module: module$1,
	files: files,
	scripts: scripts,
	repository: repository,
	keywords: keywords,
	author: author,
	license: license,
	bugs: bugs,
	homepage: homepage,
	jest: jest,
	prettier: prettier,
	devDependencies: devDependencies,
	dependencies: dependencies
};

function toKeyValue(object) {
  let newObject = {};
  for (let key in object) {
    if (typeof object[key] !== 'string') {
      newObject[key] = JSON.stringify(object[key]);
    } else {
      newObject[key] = object[key];
    }
  }
  return newObject;
}

function fromJEOL(buffer) {
  let parsedData = jeolconverter.parseJEOL(buffer);
  let info = parsedData.info;
  let headers = parsedData.headers;
  let parameters = parsedData.parameters;
  let paramArray = Object.assign({}, parameters.paramArray);
  delete parameters.paramArray;
  let data = parsedData.data;

  // curation of parameters
  let newInfo = {};
  newInfo.title = `title: ${headers.title} / comment: ${headers.comment} / author:${headers.author} / site: ${headers.site}`;
  newInfo.nucleus = info.nucleus.map((x) => {
    if (x === 'Proton') {
      x = '1H';
    }
    if (x === 'Carbon13') {
      x = '13C';
    }
    if (x === 'Nitrogen15') {
      x = '15N';
    }
    return x;
  });
  newInfo.sampleName = info.sampleName;
  newInfo.date = JSON.stringify(info.creationTime);
  newInfo.author = info.author;
  //newInfo.comment = info.comment;
  newInfo.solvent = info.solvent;
  newInfo.temperature = info.temperature.magnitude;
  newInfo.probeName = info.probeName || '';
  newInfo.fieldStrength = info.fieldStrength.magnitude;

  let gyromagneticRatioConstants = newInfo.nucleus.map(
    (nucleus) => nmrProcessing.gyromagneticRatio[nucleus],
  );
  newInfo.baseFrequency = gyromagneticRatioConstants.map(
    (gmr) => (info.fieldStrength.magnitude * gmr) / (2 * Math.PI * 1e6),
  );
  newInfo.pulseSequence = info.experiment;
  newInfo.temperature =
    info.temperature.unit.toLowerCase() === 'celsius'
      ? 273.15 + info.temperature.magnitude
      : info.temperature.magnitude;
  newInfo.digitalFilter = info.digitalFilter;
  newInfo.pulseStrength90 = 1 / (4 * info.pulseStrength90.magnitude);
  newInfo.numberOfScans = info.numberOfScans;
  newInfo.relaxationTime = info.relaxationTime.magnitude;

  newInfo.isComplex = info.dataSections.includes('im');
  newInfo.isFid = info.dataUnits[0] === 'Second';
  newInfo.isFt = info.dataUnits[0] === 'Ppm';

  newInfo.dimension = info.dimension;

  const dimension = newInfo.dimension;
  newInfo.originFrequency = info.originFrequency
    .map((d) => d.magnitude / 1e6)
    .slice(0, dimension);
  newInfo.numberOfPoints = info.dataPoints.slice(0, 1);
  newInfo.frequencyOffset = info.frequencyOffset
    .map((f, i) => f.magnitude * newInfo.baseFrequency[i])
    .slice(0, dimension);
  newInfo.acquisitionTime = info.acquisitionTime
    .map((a) => a.magnitude)
    .slice(0, dimension);
  newInfo.spectralWidth = info.spectralWidth
    .map((sw, i) => (sw.magnitude / info.originFrequency[i].magnitude) * 1e6)
    .slice(0, dimension);

  // set options for dimensions
  let dimensions = [];
  let options = {};
  let increment;
  for (let d = 0; d < info.dimension; d++) {
    increment = {
      magnitude: info.acquisitionTime[d].magnitude / (info.dataPoints[d] - 1),
      unit: 's',
    };
    if (info.dataUnits[d] === 'Second') {
      options.quantityName = 'time';
      options.originOffset = { magnitude: 0, unit: 's' };

      if (d === 0) {
        options.coordinatesOffset = {
          magnitude: info.digitalFilter * increment.magnitude,
          unit: 's',
        };
      } else {
        options.coordinatesOffset = { magnitude: 0, unit: 's' };
      }
      options.reciprocal = {
        originOffset: {
          magnitude: info.originFrequency[d].magnitude,
          unit: 'Hz',
        },
        quantityName: 'frequency',
        coordinatesOffset: {
          magnitude:
            (info.frequencyOffset[d].magnitude *
              info.originFrequency[d].magnitude) /
            1000000,
          unit: 'Hz',
        },
      };
    } else if (info.dataUnits[d] === 'Ppm') {
      options.quantityName = 'frequency';

      let origin = info.originFrequency[d].magnitude;
      options.originOffset = { magnitude: origin, unit: 'Hz' };

      let firstPoint = info.dataOffsetStart[0];
      let lastPoint = info.dataOffsetStop[0];
      let dataLength = lastPoint - firstPoint + 1;

      let spectralWidth = info.spectralWidth[d].magnitude;
      let incr = spectralWidth / info.dataPoints[d];
      increment = { magnitude: incr, unit: 'Hz' };

      let offset = (info.dataAxisStop[0] * origin) / 1000000;
      options.coordinatesOffset = {
        magnitude: offset,
        unit: 'Hz',
      };

      // after increment is computed with whole frequency
      // and original number of points, we recast the
      // number of point for export
      if (dataLength < info.dataPoints[d]) {
        info.dataPoints[d] = dataLength;
      }
    }

    if (d === 0) {
      options.description = 'direct dimension';
    } else {
      options.description = 'indirect dimension';
    }

    dimensions.push(
      formatLinearDimension(
        headers.dataAxisTitles[d],
        info.dataPoints[d],
        increment,
        options,
      ),
    );
  }

  // set options for dependentVariable
  options = {
    unit: 'none',
    quantityName: 'relative intensity',
    from: info.dataOffsetStart,
    to: info.dataOffsetStop,
  };

  let dependentVariables = [];
  dependentVariables.push(formatDependentVariable(data, 11, options));

  let description = Object.assign({}, newInfo);

  delete description.paramList;
  description.metadata = Object.assign(
    {},
    toKeyValue(headers),
    toKeyValue(parameters),
    toKeyValue(paramArray),
  );

  let dataStructure = {
    timeStamp: Date.now(),
    version: packageJson.version,
    description,
    tags: ['magnetic resonance'].concat(newInfo.nucleus),
    application: {
      spectralWidthClipped:
        info.spectralWidthClipped[0].magnitude / newInfo.baseFrequency[0],
    },
    dimensions: dimensions,
    dependentVariables: dependentVariables,
  };
  return [dataStructure];
}

function convertToFloatArray(data) {
  if (isAnyArray.isAnyArray(data[0])) {
    return data.map((e) => Float64Array.from(e));
  } else if (isAnyArray.isAnyArray(data)) {
    return Float64Array.from(data);
  } else if (typeof data === 'object') {
    let keys = Object.keys(data);
    for (let key of keys) {
      data[key] = convertToFloatArray(data[key]);
    }
    return data;
  }
  return data;
}

/* eslint-disable no-loss-of-precision */
/**
 * Returns the group delay for old Bruker NMR spectra
 * @param {number} gspfvs
 * @param {number} decim
 * @return {number}
 */
function getDigitalFilterParameters(grpdly, dspfvs, decim) {
  let value;
  if (grpdly > 0) {
    value = Number(grpdly);
  } else {
    if (dspfvs > 14) {
      value = 0;
    } else {
      if (!brukerDspTable[dspfvs]) {
        throw new Error('dspfvs not in lookup table');
      } else {
        const dspfvsList = brukerDspTable[dspfvs];
        if (!dspfvsList[decim]) throw new Error('decim not in lookup table');
        value = dspfvsList[decim];
      }
    }
  }
  return value;
}

const brukerDspTable = {
  10: {
    2: 44.75,
    3: 33.5,
    4: 66.625,
    6: 59.083333333333333,
    8: 68.5625,
    12: 60.375,
    16: 69.53125,
    24: 61.020833333333333,
    32: 70.015625,
    48: 61.34375,
    64: 70.2578125,
    96: 61.505208333333333,
    128: 70.37890625,
    192: 61.5859375,
    256: 70.439453125,
    384: 61.626302083333333,
    512: 70.4697265625,
    768: 61.646484375,
    1024: 70.48486328125,
    1536: 61.656575520833333,
    2048: 70.492431640625,
  },
  11: {
    2: 46,
    3: 36.5,
    4: 48,
    6: 50.166666666666667,
    8: 53.25,
    12: 69.5,
    16: 72.25,
    24: 70.166666666666667,
    32: 72.75,
    48: 70.5,
    64: 73,
    96: 70.666666666666667,
    128: 72.5,
    192: 71.333333333333333,
    256: 72.25,
    384: 71.666666666666667,
    512: 72.125,
    768: 71.833333333333333,
    1024: 72.0625,
    1536: 71.916666666666667,
    2048: 72.03125,
  },
  12: {
    2: 46,
    3: 36.5,
    4: 48,
    6: 50.166666666666667,
    8: 53.25,
    12: 69.5,
    16: 71.625,
    24: 70.166666666666667,
    32: 72.125,
    48: 70.5,
    64: 72.375,
    96: 70.666666666666667,
    128: 72.5,
    192: 71.333333333333333,
    256: 72.25,
    384: 71.666666666666667,
    512: 72.125,
    768: 71.833333333333333,
    1024: 72.0625,
    1536: 71.916666666666667,
    2048: 72.03125,
  },
  13: {
    2: 2.75,
    3: 2.8333333333333333,
    4: 2.875,
    6: 2.9166666666666667,
    8: 2.9375,
    12: 2.9583333333333333,
    16: 2.96875,
    24: 2.9791666666666667,
    32: 2.984375,
    48: 2.9895833333333333,
    64: 2.9921875,
    96: 2.9947916666666667,
  },
};

function getNucleusFromMetadata(metaData, info, subfix) {
  let nucleus = [];
  if (metaData[`${subfix}AXNUC`]) {
    nucleus = metaData[`${subfix}AXNUC`];
    if (!Array.isArray(nucleus)) nucleus = [nucleus];
    nucleus = checkForNucleus(nucleus);
  }

  if (nucleus.length < 1 && metaData[`${subfix}NUC1`]) {
    nucleus = metaData[`${subfix}NUC1`];
    if (!Array.isArray(nucleus)) nucleus = [nucleus];
    nucleus = checkForNucleus(nucleus);
  }

  if (nucleus.length === 0) {
    if (metaData['.NUCLEUS']) {
      nucleus = metaData['.NUCLEUS'].split(',').map((nuc) => nuc.trim());
    } else if (metaData['.OBSERVENUCLEUS']) {
      nucleus = [metaData['.OBSERVENUCLEUS'].replace(/[^A-Za-z0-9]/g, '')];
    } else {
      nucleus = getNucleusFrom2DExperiment(info.experiment);
    }
    nucleus = checkForNucleus(nucleus);
  }

  if (metaData['2D_X_NUCLEUS'] && metaData['2D_Y_NUCLEUS']) {
    nucleus = [
      metaData['2D_X_NUCLEUS'].replace(/[^A-Za-z0-9]/g, ''),
      metaData['2D_Y_NUCLEUS'].replace(/[^A-Za-z0-9]/g, ''),
    ];
  }
  return nucleus;
}

/**
 * Returns a list of likely nuclei based on an experiment string
 * This is really an hypothesis and should not be used
 * @param {string} experiment
 * @return {string[]}
 */

function getNucleusFrom2DExperiment(experiment) {
  if (typeof experiment !== 'string') {
    return [];
  }
  experiment = experiment.toLowerCase();
  if (experiment.includes('jres')) {
    return ['1H', 'Hz'];
  }
  if (experiment.includes('hmbc') || experiment.includes('hsqc')) {
    return ['1H', '13C'];
  }
  if (experiment.includes('cosy') || experiment.includes('tocsy')) {
    return ['1H', '1H'];
  }
  return [];
}

function checkForNucleus(nucleus) {
  nucleus = nucleus.map((value) =>
    value
      .replace(/[^A-Za-z0-9]/g, '')
      .replace('NA', '')
      .replace('off', ''),
  );
  let beforeLength = nucleus.length;
  nucleus = nucleus.filter((value) => value);
  return nucleus.length !== beforeLength ? [] : nucleus;
}

/**
 * Returns an experiment string based on a pulse sequence
 * @param {string} pulse
 * @return {string}
 */
function getSpectrumType(meta = {}, info = {}, options = {}) {
  const { subfix = '' } = options;

  if (meta === null) meta = {};
  if (typeof meta === 'string') meta = { pulseSequence: meta };

  let spectyp = info[`${subfix}SPECTYP`];
  spectyp = (Array.isArray(spectyp) ? spectyp[0] : spectyp || '')
    .replace(/^<(.*)>$/, '$1') // eslint-disable-line prefer-named-capture-group
    .toLowerCase();

  if (spectyp.length > 0 && spectyp !== 'undefined') return spectyp;

  let pulse = Array.isArray(meta.pulseSequence)
    ? meta.pulseSequence[0]
    : meta.pulseSequence || '';

  if (typeof pulse !== 'string') {
    return meta.dimension ? `${meta.dimension}d` : '';
  }

  pulse = pulse.toLowerCase();
  if (
    pulse.includes('zg') ||
    pulse.includes('single_pulse_dec') ||
    pulse.includes('udeft')
  ) {
    return '1d';
  }

  if (
    pulse.includes('hsqct') ||
    (pulse.includes('invi') && (pulse.includes('ml') || pulse.includes('di')))
  ) {
    return 'hsqctocsy';
  }

  if (pulse.includes('hsqc') || pulse.includes('invi')) {
    return 'hsqc';
  }

  if (
    pulse.includes('hmbc') ||
    (pulse.includes('inv4') && pulse.includes('lp'))
  ) {
    return 'hmbc';
  }

  if (pulse.includes('hmqc')) {
    return 'hmqc';
  }

  if (pulse.includes('cosy')) {
    return 'cosy';
  }

  if (pulse.includes('jres')) {
    return 'jres';
  }

  if (
    pulse.includes('tocsy') ||
    pulse.includes('mlev') ||
    pulse.includes('dipsi')
  ) {
    return 'tocsy';
  }

  if (pulse.includes('noesy')) {
    return 'noesy';
  }

  if (pulse.includes('roesy')) {
    return 'roesy';
  }

  if (pulse.includes('dept')) {
    return 'dept';
  }

  if (pulse.includes('jmod') || pulse.includes('apt')) {
    return 'aptjmod';
  }

  if (pulse.includes('inad')) {
    return 'inadequate';
  }

  if (pulse.includes('adeq')) {
    return 'adequate';
  }

  return meta.dimension ? `${meta.dimension}d` : '';
}

function getInfoFromJCAMP(metaData, options = {}) {
  const { subfix = '' } = options;
  const info = {
    dimension: 0,
    nucleus: [],
    isFid: false,
    isFt: false,
    isComplex: false,
  };
  let metadataString = JSON.stringify(metaData);
  const separator = metadataString.match('\r\n') ? '\r\n' : '\n';

  let { JCAMPDX: jcampdx = '', ORIGIN: origin = '' } = metaData;
  let creator = String(jcampdx).toLowerCase() + origin.toLowerCase();

  if (creator.includes('mestre') || creator.includes('nova')) {
    creator = 'mnova';
  }

  if (creator === 'mnova') {
    if (metaData.LONGDATE) {
      info.date = metaData.LONGDATE;
    }
  }

  info.nucleus = getNucleusFromMetadata(metaData, info, subfix);
  info.dimension = info.nucleus.length;

  maybeAdd(info, 'title', metaData.TITLE);
  maybeAdd(info, 'solvent', metaData['.SOLVENTNAME']);
  maybeAdd(info, 'temperature', metaData[`${subfix}TE`] || metaData['.TE']);
  maybeAdd(info, 'type', metaData.DATATYPE);

  if (info.type) {
    let typeLowerCase = info.type[0].toUpperCase();
    if (typeLowerCase.indexOf('FID') >= 0) {
      info.isFid = true;
      info.isComplex = true;
    } else if (typeLowerCase.indexOf('SPECTRUM') >= 0) {
      info.isFt = true;
      info.isComplex = true;
    }
  }

  maybeAdd(
    info,
    'pulseSequence',
    metaData['.PULSESEQUENCE'] ||
      metaData['.PULPROG'] ||
      metaData[`${subfix}PULPROG`],
  );
  maybeAdd(info, 'experiment', getSpectrumType(info, metaData, { subfix }));

  maybeAdd(info, 'originFrequency', metaData['.OBSERVEFREQUENCY']);

  if (creator !== 'mnova' && creator !== 'mestre') {
    const gyromagneticRatioConst = nmrProcessing.gyromagneticRatio[info.nucleus[0]];
    maybeAdd(info, 'probeName', metaData[`${subfix}PROBHD`]);
    maybeAdd(info, 'originFrequency', metaData[`${subfix}SFO1`]);
    maybeAdd(info, 'baseFrequency', metaData[`${subfix}BF1`]);

    if (!['baseFrequency', 'originFrequency'].some((e) => !info[e])) {
      const { baseFrequency, originFrequency } = info;
      let fieldStrength =
        2 * Math.PI * (baseFrequency[0] / gyromagneticRatioConst) * 1e6;

      let frequencyOffset = baseFrequency.map(
        (bf, i) => (originFrequency[i] - bf) * 1e6,
      );

      maybeAdd(info, 'fieldStrength', fieldStrength);
      maybeAdd(info, 'frequencyOffset', frequencyOffset);
    }
    maybeAdd(info, 'spectralWidth', metaData[`${subfix}SW`]);
    maybeAdd(info, 'numberOfPoints', metaData[`${subfix}TD`]);

    const numberOfPoints = info.numberOfPoints;

    maybeAdd(info, 'sampleName', metaData[`${subfix}NAME`]);

    if (metaData[`${subfix}FNTYPE`] !== undefined) {
      maybeAdd(
        info,
        'acquisitionMode',
        parseInt(metaData[`${subfix}FNTYPE`], 10),
      );
    }
    let varName = metaData[`${subfix}VARNAME`]
      ? metaData[`${subfix}VARNAME`].split(',')[0]
      : '';
    if (varName === 'TIME') {
      let value =
        typeof metaData.LAST === 'string' || metaData.LAST instanceof String
          ? metaData.LAST.replace(' ', '').split(',')[0]
          : metaData.LAST;
      maybeAdd(info, 'acquisitionTime', Number(value));
    }

    if (!info.acquisitionTime) {
      if (!['numberOfPoints', 'spectralWidth'].some((e) => !info[e])) {
        const { spectralWidth, originFrequency } = info;
        maybeAdd(
          info,
          'acquisitionTime',
          Number(
            (numberOfPoints[0] - 1) /
              (2 * spectralWidth[0] * originFrequency[0]),
          ),
        );
      }
    }

    if (metaData[`${subfix}P`]) {
      let pulseStrength =
        1e6 / (metaData[`${subfix}P`].split(separator)[1].split(' ')[1] * 4);
      maybeAdd(info, 'pulseStrength90', pulseStrength);
    }
    if (metaData[`${subfix}D`]) {
      let relaxationTime = metaData[`${subfix}D`]
        .split(separator)[1]
        .split(' ')[1];
      maybeAdd(info, 'relaxationTime', Number(relaxationTime));
    }

    maybeAdd(info, 'numberOfScans', Number(metaData[`${subfix}NS`]));

    let increment;
    if (!['numberOfPoints', 'spectralWidth'].some((e) => !info[e])) {
      const { spectralWidth, numberOfPoints } = info;
      if (info.isFid) {
        maybeAdd(info, 'groupDelay', metaData[`${subfix}GRPDLY`] || 0);
        maybeAdd(info, 'DSPFVS', metaData[`${subfix}DSPFVS`]);
        maybeAdd(info, 'DECIM', metaData[`${subfix}DECIM`]);

        if (!['groupDelay', 'DSPFVS', 'DECIM'].some((e) => !info[e])) {
          let { groupDelay, DSPFVS, DECIM } = info;
          let digitalFilterParameters = getDigitalFilterParameters(
            groupDelay[0],
            DSPFVS[0],
            DECIM[0],
          );
          maybeAdd(info, 'digitalFilter', digitalFilterParameters);
        }

        increment = numberOfPoints.map((nb) => {
          return info.acquisitionTime[0] / (nb - 1);
        });
      } else {
        increment = numberOfPoints.map((nb, i) => {
          return spectralWidth[i] / (nb - 1);
        });
      }
    }

    maybeAdd(info, 'increment', increment);
    if (metaData[`${subfix}DATE`]) {
      info.date = new Date(
        parseInt(metaData[`${subfix}DATE`], 10) * 1000,
      ).toISOString();
    }

    if (!info.solvent) {
      maybeAdd(
        info,
        'solvent',
        Array.isArray(metaData[`${subfix}SOLVENT`])
          ? metaData[`${subfix}SOLVENT`][0]
          : metaData[`${subfix}SOLVENT`],
      );
    }
  }

  if (metaData.SYMBOL) {
    let symbols = metaData.SYMBOL.split(/[, ]+/);
    if (symbols.includes('R') && symbols.includes('I')) {
      info.isComplex = true;
    }
  }

  for (let key in info) {
    if (info[key].length === 1) info[key] = info[key][0];
  }

  if (!Array.isArray(info.nucleus)) info.nucleus = [info.nucleus];

  return info;
}

function maybeAdd(obj, name, value) {
  if (value !== undefined) {
    if (Array.isArray(value)) {
      obj[name] = value.map((v) => {
        return removeUnless(v);
      });
    } else {
      obj[name] = [removeUnless(value)];
    }
  }
}

function removeUnless(value) {
  if (typeof value === 'string') {
    if (value.startsWith('<') && value.endsWith('>')) {
      value = value.substring(1, value.length - 1);
    }
    value = value.trim();
  }
  return value;
}

const defaultOptions = {
  noContour: true,
  xy: true,
  keepRecordsRegExp: /.*/,
  profiling: true,
};

async function fromBruker(zipFile, options = {}) {
  let parseData = await brukerconverter.convertZip(
    zipFile,
    { ...defaultOptions, ...options },
  );
  let dataStructure = [];
  for (let element of parseData) {
    let entry = element.value;
    let metadata = Object.assign({}, entry.info, entry.meta);
    let info = getInfoFromJCAMP(metadata);

    if (info.experiment === 'wobble_curve') continue;

    let dimensions = [];
    let dependentVariables = [];

    let dependentVariable = {};

    if (info.dimension === 1) {
      for (let i = 0; i < entry.spectra.length; i++) {
        let data = entry.spectra[i].data;
        data = convertToFloatArray(data);
      }
      dependentVariable.components = entry.spectra;
    } else if (info.dimension === 2) {
      entry.minMax.z = convertToFloatArray(entry.minMax.z);
      dependentVariable.components = entry.minMax;
    }

    let dimension = {
      increment: info.increment,
      numberOfPoints: info.numberOfPoints,
    };

    if (info.fid) {
      dimension.coordinatesOffset = {
        magnitude: -info.digitalFilter * info.increment,
        units: 'second',
      };
    } else {
      dimension.coordinatesOffset = {
        magnitude:
          info.frequencyOffset / info.baseFrequency - 0.5 * info.spectraWidth,
        units: 'ppm',
      };
    }

    dimensions.push(dimension);
    dependentVariables.push(dependentVariable);

    const { source } = entry;

    dataStructure.push({
      dimensions,
      dependentVariables,
      source,
      info: info,
      meta: metadata,
      timeStamp: new Date().valueOf(),
      version: packageJson.version,
    });
  }
  return dataStructure;
}

const expectedTypes = ['ndnmrspectrum', 'ndnmrfid', 'nmrspectrum', 'nmrfid'];

function fromJCAMP(buffer, options = {}) {
  const {
    noContour = true,
    xy = true,
    keepRecordsRegExp = /.*/,
    profiling = true,
  } = options;

  let parsedData = jcampconverter.convert(buffer, {
    noContour,
    xy,
    keepRecordsRegExp,
    profiling,
  });

  let dataStructure = [];
  let entries = parsedData.flatten;
  for (let entry of entries) {
    if (!isSpectraData(entry)) continue;
    if ((entry.spectra && entry.spectra.length > 0) || entry.minMax) {
      let metadata = Object.assign({}, entry.info, entry.meta);
      let info = getInfoFromJCAMP(metadata);

      if (info.experiment === 'wobble_curve') continue;

      let dimensions = [];
      let dependentVariables = [];

      let dependentVariable = {};
      if (info.dimension === 1) {
        for (let i = 0; i < entry.spectra.length; i++) {
          let data = entry.spectra[i].data;
          data = convertToFloatArray(data);
        }
        dependentVariable.components = entry.spectra;
      } else if (info.dimension === 2) {
        entry.minMax.z = convertToFloatArray(entry.minMax.z);
        dependentVariable.components = entry.minMax;
      }
      let dimension = {
        increment: info.increment,
        numberOfPoints: info.numberOfPoints,
      };

      if (info.fid) {
        dimension.coordinatesOffset = {
          magnitude: -info.digitalFilter * info.increment,
          units: 'second',
        };
      } else {
        dimension.coordinatesOffset = {
          magnitude:
            info.frequencyOffset / info.baseFrequency - 0.5 * info.spectraWidth,
          units: 'ppm',
        };
      }
      dimensions.push(dimension);
      dependentVariables.push(dependentVariable);

      const data = {
        dimensions,
        dependentVariables,
        info,
        meta: metadata,
        timeStamp: new Date().valueOf(),
        version: packageJson.version,
      };

      dataStructure.push(data);
    }
  }

  return dataStructure;
}

function isSpectraData(entry) {
  const { dataType = '', dataClass = '' } = entry;

  const inputDataType = dataType.replace(/\s/g, '').toLowerCase();
  const inputDataClass = dataClass.replace(/\s/g, '').toLowerCase();
  return (
    expectedTypes.some((type) => type === inputDataType) &&
    inputDataClass !== 'peak table'
  );
}

exports.formatDependentVariable = formatDependentVariable;
exports.formatLinearDimension = formatLinearDimension;
exports.fromBruker = fromBruker;
exports.fromJCAMP = fromJCAMP;
exports.fromJEOL = fromJEOL;
