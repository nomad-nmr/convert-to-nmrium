'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var maxY = require('ml-array-xy-max-y');
var FFT = require('fft.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var maxY__default = /*#__PURE__*/_interopDefaultLegacy(maxY);
var FFT__default = /*#__PURE__*/_interopDefaultLegacy(FFT);

function appendDebug(
  xin,
  yin,
  JStarArray,
  scalProd,
  loopoverJvalues,
  result,
  beforeSymSpe,
) {
  if (!result.debug) {
    result.debug = {
      steps: [],
    };
  }
  const data = {
    x: [],
    y: [],
    s: [],
  };

  let step = {};
  result.debug.steps.push(step);

  for (let i = 0; i < xin.length; i++) {
    if (yin[i] !== undefined) {
      data.x.push(xin[i]);
      data.y.push(yin[i]);
      if (!(typeof beforeSymSpe === 'undefined')) {
        data.s.push(beforeSymSpe[i]);
      }
    }
  }

  step.multiplet = data;

  const data2 = {
    x: [],
    y: [],
  };

  for (let i = 0; i < scalProd.length; i++) {
    data2.x.push(JStarArray[i]);
    data2.y.push(scalProd[i]);
  }

  step.errorFunction = data2;
}

function decofast1(yi, jStar, sign, nbLines, addspace = 0) {
  let y1 = new Float64Array(yi.length + addspace);
  for (let scan = 0; scan < addspace; scan++) {
    y1[scan] = 0;
  }
  for (let scan = 0; scan < yi.length; scan++) {
    y1[scan + addspace] = yi[scan];
  }
  if (sign === 1) {
    if (nbLines === 1) {
      for (let scan = 0; scan < y1.length - jStar; scan++) {
        y1[scan + jStar + addspace] -= y1[scan + addspace];
      }
    } else {
      for (let scan = 0; scan < y1.length - jStar * nbLines; scan++) {
        for (let line = 0; line < nbLines; line++) {
          y1[scan + (line + 1) * jStar + addspace] -= y1[scan + addspace];
        }
      }
    }
  } else {
    if (nbLines === 1) {
      for (let scan = 0; scan < y1.length - jStar; scan++) {
        y1[scan + jStar + addspace] += y1[scan + addspace];
      }
    } else {
      for (let scan = 0; scan < y1.length - jStar * nbLines; scan++) {
        for (let line = 0; line < nbLines; line++) {
          y1[scan + (line + 1) * jStar + addspace] += y1[scan + addspace];
        }
      }
    }
  }
  return y1;
}
function decofast2(yi, jStar, sign, nbLines, addspace = 0) {
  let y2 = new Float64Array(yi.length + addspace);

  for (let scan = 0; scan < yi.length; scan++) {
    y2[scan] = yi[scan];
  }
  for (let scan = 0; scan < addspace; scan++) {
    y2[scan + yi.length] = 0;
  }
  if (sign === 1) {
    if (nbLines === 1) {
      for (
        let scan = y2.length - 1 - addspace;
        scan >= jStar * nbLines;
        scan -= 1
      ) {
        y2[scan - jStar] -= y2[scan];
      }
    } else {
      for (
        let scan = y2.length - 1 - addspace;
        scan >= jStar * nbLines;
        scan -= 1
      ) {
        for (let line = 0; line < nbLines; line++) {
          y2[scan - (line + 1) * jStar] -= y2[scan];
        }
      }
    }
  } else {
    if (nbLines === 1) {
      for (
        let scan = y2.length - 1 - addspace;
        scan >= jStar * nbLines;
        scan -= 1
      ) {
        y2[scan - jStar] += y2[scan];
      }
    } else {
      for (
        let scan = y2.length - 1 - addspace;
        scan >= jStar * nbLines;
        scan -= 1
      ) {
        for (let line = 0; line < nbLines; line++) {
          y2[scan - (line + 1) * jStar] += y2[scan];
        }
      }
    }
  }
  return y2;
}

/**
 *
 * @param {number} [yi]
 * @param {number} [jStar]
 * @param {number} [sign=1]  ++ multiplet :1 +- multiplet : -1
 * @param {number} [dir=1] from left to right : 1 -1 from right to left, 0: sum of both
 * @param {number} [chopTail=1] run the end of the multiplet
 * @param {number} [multiplicity] value for spin 1/2
 */
function deco(
  yi,
  jStar,
  sign = 1,
  dir = 1,
  chopTail = 1,
  multiplicity = 0.5,
) {
  let nbLines = parseInt(2 * multiplicity, 10); // 1 for doublet (spin 1/2) 2, for spin 1, etc... never tested...
  let y1;
  let y2;
  if (dir > -1) {
    y1 = decofast1(yi, jStar, sign, nbLines, 0);

    if (dir > 0.5) {
      return new Float64Array(
        y1.buffer,
        0,
        y1.length - chopTail * jStar * nbLines,
      );
    }
  }
  if (dir < 1) {
    y2 = decofast2(yi, jStar, sign, nbLines, 0);

    if (dir < -0.2) {
      return new Float64Array(
        y2.buffer,
        chopTail * jStar * nbLines * 8,
        y2.length - chopTail * jStar * nbLines,
      );
    }
  }
  if (!y1) y1 = new Float64Array(yi.length);
  if (!y2) y2 = new Float64Array(yi.length);
  if (dir === 0) {
    for (let scan = 0; scan < y2.length - jStar * nbLines; scan++) {
      y1[scan] = (y1[scan] + sign * y2[scan + jStar * nbLines]) / 2;
    }
    return new Float64Array(y1.buffer, 0, y1.length - jStar * nbLines);
  }
  let half = ((y1.length - jStar * nbLines) / 2.0) | 0;
  if (dir === 0.1) {
    for (let scan = half; scan < y2.length - jStar * nbLines; scan++) {
      y1[scan] = sign * y2[scan + jStar * nbLines];
    }
    return new Float64Array(y1.buffer, 0, y1.length - jStar * nbLines);
  }
}

function scalarProduct(
  y1,
  y2,
  sens,
  incrementForSpeed,
  first = 0,
  last = y1.length,
) {
  // sens = 1; crude scalar product
  // sens =-1: flip spectrum first
  let v11 = 0;
  let v22 = 0;
  let v12 = 0;
  if (sens > 0) {
    for (let index = first; index < last; index += incrementForSpeed) {
      v12 += y1[index] * y2[index];
      v11 += y1[index] * y1[index];
      v22 += y2[index] * y2[index];
    }
  } else {
    // Here as if flip left/right array
    for (let index = first; index < last; index += incrementForSpeed) {
      v12 += y1[index] * y2[last - (index - first) - 1];
      v11 += y1[index] * y1[index];
      v22 += y2[index] * y2[index];
    }
  }
  return v12 / Math.sqrt(v11 * v22);
}

function measureDeco(
  y, // input vector
  jStar, // tested value of J in pt
  sign, // sign of the split 1: ++ -1: +-
  chopTail, // 1: cut tail
  multiplicity,
  incrementForSpeed,
) {
  let nbLines = parseInt(2 * multiplicity, 10); // 1 for doublet (spin 1/2) 2, for spin 1, etc... never tested...
  let y1 = decofast1(y, jStar, sign, nbLines, jStar);
  let y2 = decofast2(y, jStar, sign, nbLines, jStar);
  return sign * scalarProduct(y1, y2, 1, incrementForSpeed);
}

function measureSymShift(y, options) {
  let minimalIntegralKeptInMultiplet = 90.0;
  if (options !== undefined) {
    minimalIntegralKeptInMultiplet = options;
  }
  // set boundaries for integration (avoid chopping too much of the multiplet)
  let integral = new Float64Array(y.length);
  integral[0] = Math.abs(y[0]);
  for (let i = 1; i < y.length; i++) {
    integral[i] = integral[i - 1] + Math.abs(y[i]);
  }
  let finishingLeftPoint = y.length / 2;
  let finishingRightPoint = y.length / 2;

  for (let i = 1; i < y.length / 2; i++) {
    if (
      (integral[integral.length - 1] - integral[i - 1]) /
        integral[integral.length - 1] <
      minimalIntegralKeptInMultiplet / 100.0
    ) {
      finishingLeftPoint = i;
      break;
    }
  }
  for (let i = 1; i < y.length / 2; i++) {
    if (
      integral[integral.length - i - 1] / integral[integral.length - 1] <
      minimalIntegralKeptInMultiplet / 100.0
    ) {
      finishingRightPoint = i;
      break;
    }
  }
  let scalarProductReference;
  let scalarProductNewValue;
  let movedBy = 0;
  scalarProductReference = scalarProduct(y, y, -1, 1);

  // set boudaries of search keep 90% of spectrum
  // search left...
  for (let i = 1; i < finishingLeftPoint; i++) {
    scalarProductNewValue = scalarProduct(y, y, -1, 1, i, y.length);

    if (scalarProductNewValue > scalarProductReference) {
      scalarProductReference = scalarProductNewValue;
      movedBy = i;
    }
  }
  for (let i = 1; i < finishingRightPoint; i++) {
    scalarProductNewValue = scalarProduct(y, y, -1, 1, 0, y.length - i);

    if (scalarProductNewValue > scalarProductReference) {
      scalarProductReference = scalarProductNewValue;
      movedBy = -i;
    }
  }
  return movedBy;
}

function symmetrize(y) {
  for (let indi = 0; indi < y.length / 2; indi++) {
    const average = (y[indi] + y[y.length - 1 - indi]) / 2;
    y[indi] = average;
    y[y.length - 1 - indi] = average;
  }
  return y;
}

function trigInterpolate(
  x,
  y,
  numberOfPointOutput,
  addPhaseInterpolation,
  appliedPhaseCorrectionType,
) {
  let scale = new Float64Array(numberOfPointOutput);
  let spectrum = new Float64Array(numberOfPointOutput);

  let scaIncrement = (x[x.length - 1] - x[0]) / (x.length - 1); // delta one pt
  let scaPt = x[0]; // move to limit side - not middle of first point (half a pt left...)
  let trueWidth = scaIncrement * x.length;
  let scaIncrementInterp = trueWidth / numberOfPointOutput;

  for (let i = 0; i < numberOfPointOutput; i++) {
    scale[i] = scaPt;
    scaPt += scaIncrementInterp;
  }

  // interpolate spectrum
  // prepare input for fft apply fftshift
  let nextPowerTwoInput = 2 ** Math.ceil(Math.log2(y.length));
  let nextPowerTwoOut = 2 ** Math.ceil(Math.log2(numberOfPointOutput));

  const fft = new FFT__default['default'](nextPowerTwoInput);
  const an = fft.createComplexArray();
  const halfNumPt = Math.floor(y.length / 2); // may ignore last pt... if odd number
  const halfNumPtB = y.length - halfNumPt;
  const shiftMultiplet = nextPowerTwoInput - y.length;
  for (let i = 0; i < halfNumPt; i++) {
    an[(shiftMultiplet + i + halfNumPtB) * 2] = y[i];
  }
  for (let i = 0; i < halfNumPtB; i++) {
    an[i * 2] = y[i + halfNumPt];
  }
  const timeDomain = fft.createComplexArray();
  fft.inverseTransform(timeDomain, an);
  timeDomain[0] /= 2; // divide first point by 2 Re
  timeDomain[1] /= 2; // divide first point by 2 Im

  // move to larger array...
  const fft2 = new FFT__default['default'](nextPowerTwoOut);
  let timeDomainZeroFilled = fft2.createComplexArray();
  for (let i = 0; i < halfNumPt * 2; i++) {
    timeDomainZeroFilled[i] = timeDomain[i]; //* Math.cos((phase / 180) * Math.PI)
  }

  const interpolatedSpectrum = fft2.createComplexArray();
  fft2.transform(interpolatedSpectrum, timeDomainZeroFilled);

  const halfNumPt2 = Math.floor(numberOfPointOutput / 2);

  // applies phase change
  let phaseRad = ((addPhaseInterpolation + 0.0) / 180.0) * Math.PI; // this is for testing additional phases
  if (phaseRad !== 0.0) {
    for (let i = 0; i < 2 * halfNumPt2; i++) {
      let tmp =
        interpolatedSpectrum[i * 2] * Math.cos(phaseRad) +
        interpolatedSpectrum[i * 2 + 1] * Math.sin(phaseRad); // only Re now...
      interpolatedSpectrum[i * 2 + 1] =
        -interpolatedSpectrum[i * 2] * Math.sin(phaseRad) +
        interpolatedSpectrum[i * 2 + 1] * Math.cos(phaseRad); // only Re now...
      interpolatedSpectrum[i * 2] = tmp;
    }
  }

  let returnedPhase = 0;
  let norm;
  if (appliedPhaseCorrectionType > 0) {
    for (let i = 1; i < 100; i++) {
      let localPhaseRad = 0;
      let vectx = 0;
      let vecty = 0;
      if (appliedPhaseCorrectionType > 0) {
        for (let loop = 0; loop < 2 * halfNumPt2; loop++) {
          if (interpolatedSpectrum[loop * 2] !== 0) {
            localPhaseRad = Math.atan(
              interpolatedSpectrum[loop * 2 + 1] /
                interpolatedSpectrum[loop * 2],
            );
          } else {
            localPhaseRad =
              (Math.sign(interpolatedSpectrum[loop * 2 + 1]) * Math.PI) / 2.0;
          }
          norm = Math.sqrt(
            interpolatedSpectrum[loop * 2 + 1] *
              interpolatedSpectrum[loop * 2 + 1] +
              interpolatedSpectrum[loop * 2] * interpolatedSpectrum[loop * 2],
          );
          vectx += Math.cos(localPhaseRad) * norm;
          vecty += Math.sin(localPhaseRad) * norm;
        }
        if (vectx !== 0) {
          localPhaseRad = Math.atan(vecty / vectx);
        } else {
          localPhaseRad = (Math.sign(vecty) * Math.PI) / 2.0;
        }
      }
      norm = Math.sqrt(vecty * vecty + vectx * vectx);
      phaseRad = -(10.0 / (i * i)) * Math.sign(vecty);

      returnedPhase -= (180.0 * phaseRad) / Math.PI;

      if (phaseRad !== 0.0) {
        for (let loop = 0; loop < 2 * halfNumPt2; loop++) {
          let tmp =
            interpolatedSpectrum[loop * 2] * Math.cos(phaseRad) +
            interpolatedSpectrum[loop * 2 + 1] * Math.sin(phaseRad); // only Re now...
          interpolatedSpectrum[loop * 2 + 1] =
            -interpolatedSpectrum[loop * 2] * Math.sin(phaseRad) +
            interpolatedSpectrum[loop * 2 + 1] * Math.cos(phaseRad); // only Re now...
          interpolatedSpectrum[loop * 2] = tmp;
        }
      }
    }
  }

  // applies fftshift
  let dropPoints = nextPowerTwoOut - numberOfPointOutput;
  for (let i = 0; i < halfNumPt2; i++) {
    spectrum[i] = interpolatedSpectrum[(halfNumPt2 + dropPoints + i) * 2]; // only Re now...
  }
  for (let i = 0; i < halfNumPt2; i++) {
    spectrum[i + halfNumPt2] = interpolatedSpectrum[i * 2];
  }
  if (returnedPhase > 360.0) {
    returnedPhase -= 360.0;
  }

  return {
    spectrum,
    scale,
    phaseCorrectionOnMultipletInDeg: returnedPhase,
  };
}

/**
 * Analyse X / Y array and extract multiplicity
 * @param {object} [data={}] An object containing properties x and y
 * @param {object} [options={}] Options (default is empty object)
 * @param {number} [options.frequency=400] Acquisition frequency, default is 400 MHz
 */

/**
 * Analyse a multiplet
 * @param {object} [data] object of the kind {x:[], y:[]} containing the multiplet
 * @param {object} [options={}]
 * @param {number} [options.frequency=400] frequency
 * @param {boolean} [options.debug=false] generate debug information if true
 */

function analyseMultiplet(data = {}, options = {}) {
  let { x = [], y = [] } = data;

  if (!(x instanceof Float64Array)) x = Float64Array.from(x);
  if (!(y instanceof Float64Array)) y = Float64Array.from(y);

  const {
    frequency = 400,
    debug = false,
    maxTestedJ = 20,
    minTestedJ = 1,
    minimalResolution = 0.01,
    correctVerticalOffset = true,
    makeShortCutForSpeed = true,
    critFoundJ = 0.9,
    sign = 1,
    chopTail = true,
    multiplicity = 0.5,
    symmetrizeEachStep = false,
    takeBestPartMultiplet = false,
    addPhaseInterpolation = 0,
    forceFirstDeconvolutionToThisValue = 0,
    appliedPhaseCorrectionType = 0,
    decreasingJvalues = true,
    jumpUpAfterFoundValue = 2.0,
  } = options;

  let result = {};
  result.js = [];
  const maxNumberOfCoupling = 12;
  //option see if cut is good. (should we cut more or interpolate if cut too close to peak - cause artifacts in both cases)

  // determine if need interpolation
  let resolutionPpm = Math.abs(x[0] - x[x.length - 1]) / (x.length - 1);
  let resolutionHz = resolutionPpm * frequency;

  let factorResolution = resolutionHz / minimalResolution;

  let nextPowerTwo = 2 ** Math.ceil(Math.log2(x.length * factorResolution));
  let nextPowerTwoInital = 2 ** Math.ceil(Math.log2(x.length));

  let integerFactorResolution = nextPowerTwo / nextPowerTwoInital;

  let movedBy;
  let scale;
  let spectrum;
  let topPosJ = 0;
  // adjust vertical offset
  if (correctVerticalOffset) {
    let minValue = 1e20;
    for (let index = 0; index < y.length; index++) {
      if (minValue > y[index]) {
        minValue = y[index];
      }
    }
    if (minValue > 0) {
      for (let index = 0; index < y.length; index++) {
        y[index] -= minValue;
      }
    }
  }
  if (resolutionHz > minimalResolution) {
    // need increase resolution
    let returned = trigInterpolate(
      x,
      y,
      integerFactorResolution * y.length,
      addPhaseInterpolation,
      appliedPhaseCorrectionType,
    );

    spectrum = returned.spectrum;
    scale = returned.scale;
    result.phaseCorrectionOnMultipletInDeg =
      returned.phaseCorrectionOnMultipletInDeg;
  } else {
    scale = x;
    spectrum = y;
  }

  resolutionPpm =
    Math.abs(scale[0] - scale[scale.length - 1]) / (scale.length - 1);
  resolutionHz = resolutionPpm * frequency;
  let maxTestedPt = Math.trunc(maxTestedJ / resolutionHz);
  let minTestedPt = Math.trunc(minTestedJ / resolutionHz) + 1;
  // will find center of symmetry of the multiplet
  // add zeroes as to make it symetrical if requested... and needed

  // main J-coupling determination
  // not calculated - set to -1

  let incrementForSpeed = 1;
  let curIncrementForSpeed;

  incrementForSpeed = (1 + 0.3 / minimalResolution) | 0; // 1 could be set better (according to line widht ?!)
  for (
    let loopoverJvalues = 1;
    loopoverJvalues < maxNumberOfCoupling;
    loopoverJvalues++
  ) {
    let scalProd = [];
    let jStarArray = [];
    for (let jStar = 0; jStar < minTestedPt; jStar++) {
      jStarArray[jStar] = jStar * resolutionHz;
      scalProd[jStar] = 0;
    }
    let beforeSymSpe = new Float64Array(spectrum.length);

    //symmetrize if requested to
    if (symmetrizeEachStep === true) {
      movedBy = -measureSymShift(spectrum);
      if (movedBy > 0) {
        spectrum = spectrum.slice(0, spectrum.length - movedBy);
        scale = scale.slice(0, scale.length - movedBy);
      }
      if (movedBy < 0) {
        spectrum = spectrum.slice(-movedBy, spectrum.length);
        scale = scale.slice(-movedBy, scale.length);
      }
      if (debug) {
        // save this to plot it as well
        for (let index = 0; index < spectrum.length; index++) {
          beforeSymSpe[index] = spectrum[index];
        }
      }
      spectrum = symmetrize(spectrum);
    }

    let topValue = -1;
    let gotJValue = false;
    let limitCoupling = scale.length - 1; //limit with respect to size of spectrum (which is reducing at each step)
    let critFoundJLow = critFoundJ - 0.3;
    if (maxTestedPt > limitCoupling) {
      maxTestedPt = limitCoupling;
    }
    if (loopoverJvalues > 1 && decreasingJvalues) {
      if (
        maxTestedPt > Math.floor(topPosJ + jumpUpAfterFoundValue / resolutionHz)
      ) {
        maxTestedPt = Math.floor(
          topPosJ + jumpUpAfterFoundValue / resolutionHz,
        );
      }
    }
    curIncrementForSpeed = incrementForSpeed;
    let jStarFine;
    for (let jStar = minTestedPt; jStar < maxTestedPt; jStar++) {
      jStarArray[jStar] = jStar * resolutionHz;
      scalProd[jStar] = -1;
    }
    for (
      let jStar = maxTestedPt;
      jStar >= minTestedPt;
      jStar -= incrementForSpeed
    ) {
      scalProd[jStar] = measureDeco(
        spectrum,
        jStar,
        sign,
        chopTail,
        multiplicity,
        curIncrementForSpeed,
      );

      jStarArray[jStar] = jStar * resolutionHz;
      if (!gotJValue) {
        if (scalProd[jStar] > topValue) {
          topValue = scalProd[jStar];
          topPosJ = jStar;
        }

        if (jStar < maxTestedPt - 2 * curIncrementForSpeed) {
          if (
            scalProd[jStar] < scalProd[jStar + curIncrementForSpeed] &&
            scalProd[jStar + curIncrementForSpeed] >=
              scalProd[jStar + 2 * curIncrementForSpeed] &&
            scalProd[jStar + curIncrementForSpeed] > critFoundJLow
          ) {
            while (curIncrementForSpeed > 1) {
              curIncrementForSpeed = Math.floor(curIncrementForSpeed / 2); // get smaller and smaller step
              let froms = topPosJ - 2 * curIncrementForSpeed; // maybe 1 is enough....
              while (froms < 0) froms += curIncrementForSpeed;
              let tos = topPosJ + 2 * curIncrementForSpeed; // maybe 1 is enough....
              while (tos >= maxTestedPt) tos -= curIncrementForSpeed;
              topValue = -1; // reset because increased precision may make the top lower
              for (
                jStarFine = froms;
                jStarFine <= tos;
                jStarFine += curIncrementForSpeed
              ) {
                scalProd[jStarFine] = measureDeco(
                  spectrum,
                  jStarFine,
                  sign,
                  chopTail,
                  multiplicity,
                  curIncrementForSpeed,
                );
                if (scalProd[jStarFine] > topValue) {
                  topValue = scalProd[jStarFine];
                  topPosJ = jStarFine;
                }
              }
            }
            curIncrementForSpeed = incrementForSpeed;
            // end refine
            if (topValue > critFoundJ) {
              // ugly force value for tests
              if (
                forceFirstDeconvolutionToThisValue > 0 &&
                loopoverJvalues === 1 &&
                gotJValue === false
              ) {
                topPosJ = Math.floor(
                  forceFirstDeconvolutionToThisValue / resolutionHz,
                );
                topValue = 1.1;
              }

              result.js.push({
                multiplicity: 'd',
                coupling: topPosJ * resolutionHz,
              });
              gotJValue = true;

              if (makeShortCutForSpeed) {
                break;
              }
            }
          }
        }
      }
    }

    if (debug) {
      if (symmetrizeEachStep === true) {
        appendDebug(
          scale,
          spectrum,
          jStarArray,
          scalProd,
          loopoverJvalues,
          result,
          beforeSymSpe,
        );
      } else {
        appendDebug(
          scale,
          spectrum,
          jStarArray,
          scalProd,
          loopoverJvalues,
          result,
        );
      }
    }

    if (!gotJValue) {
      break;
    } else {
      // apply here the deconvolution for the next step of the recursive process
      spectrum = deco(
        spectrum,
        topPosJ,
        sign,
        0 + 0.1 * takeBestPartMultiplet,
        chopTail,
        multiplicity,
      ); // for next step
      if (chopTail) {
        let remove = 0.5 * topPosJ * (2 * multiplicity);
        scale = scale.slice(remove, scale.length - remove);
      }
      if (scale.length !== spectrum.length) {
        throw Error('sts');
      }
    }
  }
  // to be tested ...

  let maxAmplitudePosition = maxY__default['default']({ x: scale, y: spectrum });
  result.chemShift = scale[maxAmplitudePosition.index];
  return result;
}

/* matlab code :
%%  demo deconvolution of J. coupling
clear all

%% deconvolution constants
min_j=1.5;%depend on the linewidth of the signal
max_j=21;%typically largest JHH couling
symmetrize=1;%symetrize multiplet at each step of deconvolution
center=1;%center multiplet before analysis

%spectral parameter (to be fixed)
hz_per_pt=0.1;% to be fixed and set to swh/si

%% interplation parameter
interpolate_factor=4;

%% read data

figure(100)
plot(segment)

%% interpolate segment
segment_int=interpft(segment,size(segment,1)*interpolate_factor);

figure(101)
plot(segment_int)

hz_per_pt_interp=hz_per_pt/interpolate_factor;
figure(2);clf;plot(segment_int);hold on
plot(round(size(segment_int,1)/2),0,'k+')

%% verify centered
figure(3);clf;
plot(segment_int);hold on
plot(flipud(segment_int));hold on
plot(round(size(segment_int,1)/2),0,'k+')
title('check centered')

%%determin range of tested couplings
from_pt=round(min_j/hz_per_pt_interp);
top_pt=round(max_j/hz_per_pt_interp);

min_val_for_scal_prod=0.9;
fast_skip=1;
number_of_coupling_looked_in_multiplet=5;
figure(10);clf
figure(11);clf
table_of_J=zeros(1,number_of_coupling_looked_in_multiplet);

figure(4);clf;
plot(segment_int);hold on
plot(flipud(segment_int));hold on
plot(round(size(segment_int,1)/2),0,'k+')
title('check centered')
for main_j_loop=1:number_of_coupling_looked_in_multiplet%:10
  if top_pt>size(segment_int,1)
      top_pt=size(segment_int,1);
  end

  % center
  if center
  [segment_int, shifted_by]=center_spectrum(segment_int');
  segment_int=segment_int';
  disp(['Shifted by ' num2str(shifted_by) ' pt'])
  end

  % symmetrize
  if symmetrize
  segment_int= flipud(segment_int)*0.5+0.5*segment_int;
      disp(['Symmetrized'])

  end
  list_of_j=top_pt:-1:from_pt;
  sijl=size(list_of_j,2);
  symt=zeros(1,sijl);
  symj=zeros(1,sijl);
  figure(11)
  subplot(number_of_coupling_looked_in_multiplet,1,main_j_loop)
  plot(segment_int);hold on
  plot(flipud(segment_int));
  figure(10)
  subplot(number_of_coupling_looked_in_multiplet,1,main_j_loop)
  inc2=0;
  top_pos=0;
  for jstarpt=list_of_j
      %apply doublet deconvolution
      [v1, v2]=deco(segment_int',jstarpt);
      v1=v1';v2=v2';
      %test symetry of result
      levelp_now=sum(sum((v1.*v2)))/(sqrt(sum(sum(((v1.*v1)))))*sqrt(sum(sum(v2.*v2))));
      %store data
      symt(1,sijl-inc2+1)=levelp_now;
      symj(1,sijl-inc2+1)=jstarpt;
      %search extrema
      if inc2>3
          if ( symt(1,sijl-inc2+3)<(symt(1,sijl-inc2+2))) && (symt(1,sijl-inc2+2)>levelp_now)
              if symt(1,sijl-inc2+2)>min_val_for_scal_prod
                  if top_pos==0
                      top_pos=sijl-inc2+2;
                      plot(symj(top_pos)*hz_per_pt_interp,symt(top_pos),'r+');hold on
                      if fast_skip==0
                          break
                      end
                  end
              end
              %  break;
          end
      end
      inc2=inc2+1;
  end
  plot([min_j max_j],min_val_for_scal_prod*[ 1 1],'r:');hold on
  plot(symj*hz_per_pt_interp,symt);hold on
  title(['No max above ' num2str(min_val_for_scal_prod,3)])
  axis([min_j max_j 0 1.1])
  axis([min_j max_j 0 1.1])
  if top_pos~=0
      title(['J(' num2str(main_j_loop) ')=' num2str(symj(top_pos)*hz_per_pt_interp,3) ' Hz'])

      =symj(top_pos);
      [v1, v2]=deco(segment_int',nbpt);
      segment_int=(v1*0.5+0.5*v2)';
      table_of_J(1,main_j_loop)=symj(top_pos)*hz_per_pt_interp;
  else
      break
  end

end
table_of_J
*/

exports.analyseMultiplet = analyseMultiplet;
