import { getShape1D } from 'ml-peak-shape-generator';
import { optimize } from 'ml-spectra-fitting';
import { xGetFromToIndex } from 'ml-spectra-processing';
import { appendShapeAndFWHM } from '../utils/appendShapeAndFWHM';
import { groupPeaks } from '../utils/groupPeaks';
/**
 * Optimize the position (x), max intensity (y), full width at half maximum (fwhm)
 * and the ratio of gaussian contribution (mu) if it's required. It currently supports three kind of shapes: gaussian, lorentzian and pseudovoigt
 * @param data - An object containing the x and y data to be fitted.
 * @param peakList - A list of initial parameters to be optimized. e.g. coming from a peak picking [{x, y, width}].
 */
export function optimizePeaks(data, peakList, options = {}) {
    const { shape = { kind: 'gaussian' }, groupingFactor = 1, factorLimits = 2, optimization = {
        kind: 'lm',
        options: {
            timeout: 10,
        },
    }, } = options;
    /*
    The optimization algorithm will take some group of peaks.
    We can not simply optimize everything because there would be too many variables to optimize
    and it would be too time consuming.
  */
    let groups = groupPeaks(peakList, { factor: groupingFactor });
    let results = [];
    groups.forEach((peakGroup) => {
        // In order to make optimization we will add fwhm and shape on all the peaks
        const peaks = appendShapeAndFWHM(peakGroup, { shape });
        const firstPeak = peaks[0];
        const lastPeak = peaks[peaks.length - 1];
        const from = firstPeak.x - firstPeak.width * factorLimits;
        const to = lastPeak.x + lastPeak.width * factorLimits;
        const { fromIndex, toIndex } = xGetFromToIndex(data.x, { from, to });
        const x = data.x instanceof Float64Array
            ? data.x.subarray(fromIndex, toIndex)
            : data.x.slice(fromIndex, toIndex);
        const y = data.y instanceof Float64Array
            ? data.y.subarray(fromIndex, toIndex)
            : data.y.slice(fromIndex, toIndex);
        if (x.length > 5) {
            let { peaks: optimizedPeaks } = optimize({ x, y }, peaks, {
                shape,
                optimization,
            });
            for (let i = 0; i < peaks.length; i++) {
                results.push({
                    x: optimizedPeaks[i].x,
                    y: optimizedPeaks[i].y,
                    shape: peaks[i].shape,
                    fwhm: optimizedPeaks[i].fwhm || 0,
                    width: getShape1D(peaks[i].shape).fwhmToWidth(optimizedPeaks[i].fwhm),
                });
            }
        }
        else {
            results = results.concat(peaks);
        }
    });
    return results;
}
//# sourceMappingURL=optimizePeaks.js.map