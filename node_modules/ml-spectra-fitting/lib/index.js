"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimize = void 0;
const checkInput_1 = require("./util/checkInput");
const selectMethod_1 = require("./util/selectMethod");
/**
 * Fits a set of points to the sum of a set of bell functions.
 *
 * @param data - An object containing the x and y data to be fitted.
 * @param peakList - A list of initial parameters to be optimized. e.g. coming from a peak picking [{x, y, width}].
 * @param options - Options.
 * @returns - An object with fitting error and the list of optimized parameters { parameters: [ {x, y, width} ], error } if the kind of shape is pseudoVoigt mu parameter is optimized.
 */
function optimize(data, peakList, options = {}) {
    if (!options.shape) {
        options = { ...options, ...{ shape: { kind: 'gaussian' } } };
    }
    const { y, x, maxY, minY, peaks, paramsFunc, optimization } = (0, checkInput_1.checkInput)(data, peakList, options);
    let parameters = optimization.parameters;
    let nbShapes = peaks.length;
    let parameterKey = Object.keys(parameters);
    let nbParams = nbShapes * parameterKey.length;
    let pMin = new Float64Array(nbParams);
    let pMax = new Float64Array(nbParams);
    let pInit = new Float64Array(nbParams);
    let gradientDifference = new Float64Array(nbParams);
    for (let i = 0; i < nbShapes; i++) {
        let peak = peaks[i];
        for (let k = 0; k < parameterKey.length; k++) {
            let key = parameterKey[k];
            let init = parameters[key].init;
            let min = parameters[key].min;
            let max = parameters[key].max;
            let gradientDifferenceValue = parameters[key].gradientDifference;
            pInit[i + k * nbShapes] = init[i % init.length](peak);
            pMin[i + k * nbShapes] = min[i % min.length](peak);
            pMax[i + k * nbShapes] = max[i % max.length](peak);
            gradientDifference[i + k * nbShapes] =
                gradientDifferenceValue[i % gradientDifferenceValue.length](peak);
        }
    }
    let { algorithm, optimizationOptions } = (0, selectMethod_1.selectMethod)(optimization);
    optimizationOptions.minValues = pMin;
    optimizationOptions.maxValues = pMax;
    optimizationOptions.initialValues = pInit;
    optimizationOptions.gradientDifference = gradientDifference;
    let pFit = algorithm({ x, y }, paramsFunc, optimizationOptions);
    let { parameterError: error, iterations } = pFit;
    let result = { error, iterations, peaks };
    for (let i = 0; i < nbShapes; i++) {
        for (let k = 0; k < parameterKey.length; k++) {
            const key = parameterKey[k];
            const value = pFit.parameterValues[i + k * nbShapes];
            if (key === 'x' || key === 'fwhm') {
                peaks[i][key] = value;
            }
            else if (key === 'y') {
                peaks[i][key] = value * maxY + minY;
            }
            else {
                peaks[i].shape[key] = value;
            }
        }
    }
    return result;
}
exports.optimize = optimize;
//# sourceMappingURL=index.js.map