'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var JSZip = require('jszip');
var jcampconverter = require('jcampconverter');
var iobuffer = require('iobuffer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var JSZip__default = /*#__PURE__*/_interopDefaultLegacy(JSZip);

/**
 * Those functions should disappear if add2D becomes accessible in jcampconvert
 * @param spectra
 * @returns {{z: Array, minX: *, maxX: *, minY: *, maxY: *, minZ: *, maxZ: *, noise: number}}
 */

function convertTo3DZ(spectra) {
  let noise = 0;
  let minZ = spectra[0].data[0];
  let maxZ = minZ;
  let ySize = spectra.length;
  let xSize = spectra[0].data.length / 2;
  let z = new Array(ySize);
  for (let i = 0; i < ySize; i++) {
    z[i] = new Float64Array(xSize);
    for (let j = 0; j < xSize; j++) {
      z[i][j] = spectra[i].data[j * 2 + 1];
      if (z[i][j] < minZ) minZ = spectra[i].data[j * 2 + 1];
      if (z[i][j] > maxZ) maxZ = spectra[i].data[j * 2 + 1];
      if (i !== 0 && j !== 0) {
        noise +=
          Math.abs(z[i][j] - z[i][j - 1]) + Math.abs(z[i][j] - z[i - 1][j]);
      }
    }
  }
  const firstX = spectra[0].data[0];
  const lastX = spectra[0].data[spectra[0].data.length - 2]; // has to be -2 because it is a 1D array [x,y,x,y,...]
  const firstY = spectra[0].pageValue;
  const lastY = spectra[ySize - 1].pageValue;

  // Because the min / max value are the only information about the matrix if we invert
  // min and max we need to invert the array
  if (firstX > lastX) {
    for (let spectrum of z) {
      spectrum.reverse();
    }
  }
  if (firstY > lastY) {
    z.reverse();
  }

  let minMaxX =
    firstX < lastX
      ? { minX: firstX, maxX: lastX }
      : { minX: lastX, maxX: firstX };
  let minMaxY =
    firstY < lastY
      ? { minY: firstY, maxY: lastY }
      : { minY: lastY, maxY: firstY };

  return {
    z,
    minZ: minZ,
    maxZ: maxZ,
    ...minMaxX,
    ...minMaxY,
    noise: noise / ((ySize - 1) * (xSize - 1) * 2),
  };
}

function generateContourLines(zData) {
  let noise = zData.noise;
  let z = zData.z;
  let contourLevels = [];
  let nbLevels = 7;
  let povarHeight = new Float32Array(4);
  let isOver = [];
  let nbSubSpectra = z.length;
  let nbPovars = z[0].length;
  let pAx, pAy, pBx, pBy;

  let x0 = zData.minX;
  let xN = zData.maxX;
  let dx = (xN - x0) / (nbPovars - 1);
  let y0 = zData.minY;
  let yN = zData.maxY;
  let dy = (yN - y0) / (nbSubSpectra - 1);
  let minZ = zData.minZ;
  let maxZ = zData.maxZ;

  // System.out.prvarln('y0 '+y0+' yN '+yN);
  // -------------------------
  // Povars attribution
  //
  // 0----1
  // |  / |
  // | /  |
  // 2----3
  //
  // ---------------------d------

  let lineZValue;
  for (let level = 0; level < nbLevels * 2; level++) {
    // multiply by 2 for positif and negatif
    let contourLevel = {};
    contourLevels.push(contourLevel);
    let side = level % 2;
    if (side === 0) {
      lineZValue =
        (maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) + 5 * noise;
    } else {
      lineZValue =
        -(maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) - 5 * noise;
    }
    let lines = [];
    contourLevel.zValue = lineZValue;
    contourLevel.lines = lines;

    if (lineZValue <= minZ || lineZValue >= maxZ) continue;

    for (let iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {
      for (let povar = 0; povar < nbPovars - 1; povar++) {
        povarHeight[0] = z[iSubSpectra][povar];
        povarHeight[1] = z[iSubSpectra][povar + 1];
        povarHeight[2] = z[iSubSpectra + 1][povar];
        povarHeight[3] = z[iSubSpectra + 1][povar + 1];

        for (let i = 0; i < 4; i++) {
          isOver[i] = povarHeight[i] > lineZValue;
        }

        // Example povar0 is over the plane and povar1 and
        // povar2 are below, we find the varersections and add
        // the segment
        if (isOver[0] !== isOver[1] && isOver[0] !== isOver[2]) {
          pAx =
            povar +
            (lineZValue - povarHeight[0]) / (povarHeight[1] - povarHeight[0]);
          pAy = iSubSpectra;
          pBx = povar;
          pBy =
            iSubSpectra +
            (lineZValue - povarHeight[0]) / (povarHeight[2] - povarHeight[0]);
          lines.push(
            pAx * dx + x0,
            pAy * dy + y0,
            pBx * dx + x0,
            pBy * dy + y0,
          );
        }
        if (isOver[3] !== isOver[1] && isOver[3] !== isOver[2]) {
          pAx = povar + 1;
          pAy =
            iSubSpectra +
            1 -
            (lineZValue - povarHeight[3]) / (povarHeight[1] - povarHeight[3]);
          pBx =
            povar +
            1 -
            (lineZValue - povarHeight[3]) / (povarHeight[2] - povarHeight[3]);
          pBy = iSubSpectra + 1;
          lines.push(
            pAx * dx + x0,
            pAy * dy + y0,
            pBx * dx + x0,
            pBy * dy + y0,
          );
        }
        // test around the diagonal
        if (isOver[1] !== isOver[2]) {
          pAx =
            povar +
            1 -
            (lineZValue - povarHeight[1]) / (povarHeight[2] - povarHeight[1]);
          pAy =
            iSubSpectra +
            (lineZValue - povarHeight[1]) / (povarHeight[2] - povarHeight[1]);
          if (isOver[1] !== isOver[0]) {
            pBx =
              povar +
              1 -
              (lineZValue - povarHeight[1]) / (povarHeight[0] - povarHeight[1]);
            pBy = iSubSpectra;
            lines.push(
              pAx * dx + x0,
              pAy * dy + y0,
              pBx * dx + x0,
              pBy * dy + y0,
            );
          }
          if (isOver[2] !== isOver[0]) {
            pBx = povar;
            pBy =
              iSubSpectra +
              1 -
              (lineZValue - povarHeight[2]) / (povarHeight[0] - povarHeight[2]);
            lines.push(
              pAx * dx + x0,
              pAy * dy + y0,
              pBx * dx + x0,
              pBy * dy + y0,
            );
          }
          if (isOver[1] !== isOver[3]) {
            pBx = povar + 1;
            pBy =
              iSubSpectra +
              (lineZValue - povarHeight[1]) / (povarHeight[3] - povarHeight[1]);
            lines.push(
              pAx * dx + x0,
              pAy * dy + y0,
              pBx * dx + x0,
              pBy * dy + y0,
            );
          }
          if (isOver[2] !== isOver[3]) {
            pBx =
              povar +
              (lineZValue - povarHeight[2]) / (povarHeight[3] - povarHeight[2]);
            pBy = iSubSpectra + 1;
            lines.push(
              pAx * dx + x0,
              pAy * dy + y0,
              pBx * dx + x0,
              pBy * dy + y0,
            );
          }
        }
      }
    }
  }

  return {
    minX: zData.minX,
    maxX: zData.maxX,
    minY: zData.minY,
    maxY: zData.maxY,
    segments: contourLevels,
  };
}

function add2D(result, options) {
  let zData = convertTo3DZ(result.spectra);
  if (!options.noContours) {
    result.contourLines = generateContourLines(zData);
  }
  result.minMax = zData;
}

function parseData(file, options) {
  let { keepRecordsRegExp = /.*/ } = options;
  let result = jcampconverter.convert(file, {
    keepRecordsRegExp: keepRecordsRegExp,
  });
  return result.flatten.length === 0 ? {} : result.flatten[0];
}

function ensureIOBuffer(data) {
  if (data instanceof Array || data instanceof Uint8Array) {
    data = new ArrayBuffer(data);
  }
  if (data instanceof ArrayBuffer) {
    return new iobuffer.IOBuffer(data);
  }
  return data;
}

function setFIDSpectrumData(file, spectra) {
  file = ensureIOBuffer(file);
  let td = parseInt(spectra.meta.TD[0], 10);
  let SW_H = parseFloat(spectra.meta.SW_h[0]);

  let SF = parseFloat(spectra.meta.SFO1[0]);

  spectra.meta.DATATYPE = 'NMR FID';

  let DW = 1 / (2 * SW_H);
  let AQ = td * DW;

  let endian = parseInt(spectra.meta.BYTORDA, 10);
  endian = endian ? 0 : 1;

  if (endian) {
    file.setLittleEndian();
  } else {
    file.setBigEndian();
  }

  let nbSubSpectra = spectra.meta.nbSubSpectra ? spectra.meta.nbSubSpectra : 1;
  spectra.spectra = new Array(nbSubSpectra);

  for (let j = 0; j < nbSubSpectra / 2; j++) {
    let toSave = {
      dataType: 'NMR FID',
      dataTable: '(X++(R..R))',
      nbPoints: td,
      firstX: 0,
      lastX: AQ,
      nucleus: spectra.meta.NUC1,
      xUnit: 'Sec',
      yUnit: 'Arbitrary',
      data: [new Float64Array(2 * td)],
      isXYdata: true,
      observeFrequency: SF,
      title: spectra.meta.TITLE,
      deltaX: DW,
    };
    spectra.spectra[j * 2] = toSave;

    toSave = {
      dataType: 'NMR FID',
      dataTable: '(X++(I..I))',
      nbPoints: td,
      firstX: 0,
      lastX: AQ,
      nucleus: spectra.meta.NUC1,
      xUnit: 'Sec',
      yUnit: 'Arbitrary',
      data: new Float64Array(2 * td),
      isXYdata: true,
      directFrequency: SF,
      title: spectra.meta.TITLE,
      deltaX: DW,
    };
    spectra.spectra[j * 2 + 1] = toSave;

    let i = 0;
    let x = 0;
    for (; file.available(8) && i < td; i++, x = i * DW) {
      let y = file.readInt32();
      if (y === null || isNaN(y)) {
        y = 0;
      }
      spectra.spectra[j * 2].data[2 * i + 1] = y;
      spectra.spectra[j * 2].data[2 * i] = x;
      y = file.readInt32();
      if (y === null || isNaN(y)) {
        y = 0;
      }
      spectra.spectra[j * 2 + 1].data[2 * i + 1] = y;
      spectra.spectra[j * 2 + 1].data[2 * i] = x;
    }

    for (; i < td; i++, x = i * DW) {
      spectra.spectra[j * 2].data[2 * i + 1] = 0;
      spectra.spectra[j * 2].data[2 * i] = x;
      spectra.spectra[j * 2 + 1].data[2 * i + 1] = 0;
      spectra.spectra[j * 2 + 1].data[2 * i] = x;
    }
  }
}

function setXYSpectrumData(file, spectra, real) {
  file = ensureIOBuffer(file);
  let td = parseInt(spectra.meta.SI, 10);
  let swP = parseFloat(spectra.meta.SW_p);
  let sf = parseFloat(spectra.meta.SF);
  let bf = sf;
  let offset = spectra.shiftOffsetVal || parseFloat(spectra.meta.OFFSET);

  spectra.meta.observeFrequency = sf;
  spectra.meta.brukerReference = bf;
  spectra.meta.DATATYPE = 'NMR Spectrum';

  let endian = parseInt(spectra.meta.BYTORDP, 10);
  endian = endian ? 0 : 1;

  let nbSubSpectra = spectra.meta.nbSubSpectra ? spectra.meta.nbSubSpectra : 1;

  if (endian) {
    file.setLittleEndian();
  } else {
    file.setBigEndian();
  }
  for (let i = 0; i < nbSubSpectra; i++) {
    let toSave = {
      dataType: 'NMR Spectrum',
      dataTable: '(X++(R..R))',
      nbPoints: td,
      firstX: offset,
      lastX: offset - swP / sf,
      xUnit: 'PPM',
      yUnit: 'Arbitrary',
      data: new Float64Array(td * 2),
      isXYdata: true,
      observeFrequency: sf,
      title: spectra.meta.TITLE,
      deltaX: -(swP / sf) / (td - 1),
    };

    let x = offset;
    let deltaX = toSave.deltaX;

    if (real) {
      for (let k = 0; k < td; ++k) {
        toSave.data[2 * k] = x;
        toSave.data[2 * k + 1] = file.readInt32();
        if (toSave.data[2 * k + 1] === null || isNaN(toSave.data[2 * k + 1])) {
          toSave.data[2 * k + 1] = 0;
        }
        x += deltaX;
      }
    } else {
      for (let k = 0; k < td; ++k) {
        toSave.data[2 * k] = x;
        toSave.data[2 * k + 1] = file.readInt32();
        if (toSave.data[2 * k + 1] === null || isNaN(toSave.data[2 * k + 1])) {
          toSave.data[2 * k + 1] = 0;
        }
        x += deltaX;
      }
    }

    spectra.spectra.push(toSave);
  }
}

function convert1D(files, options) {
  let result = parseData(files.procs || '', options);
  let temp = parseData(files.acqus || '', options);
  if (!Object.keys(result).length) {
    result = temp;
  }

  for (let key in result.meta) {
    result.meta[key] = [result.meta[key]];
  }

  for (let currKey in temp.meta) {
    if (result.meta[currKey] === undefined) {
      result.meta[currKey] = [temp.meta[currKey]];
    }
  }

  if (files['1r'] || files['1i']) {
    if (files['1r']) {
      setXYSpectrumData(files['1r'], result, true);
    }
    if (files['1i']) {
      setXYSpectrumData(files['1i'], result, false);
    }
  } else if (files.fid) {
    setFIDSpectrumData(files.fid, result);
  }

  return result;
}

function mergeMetadata(main, complement) {
  for (let key in complement.meta) {
    if (main.meta[key]) {
      if (!Array.isArray(main.meta[key])) {
        main.meta[key] = [main.meta[key]];
      }
      main.meta[key].push(complement.meta[key]);
    } else if (main.meta[key] === undefined) {
      main.meta[key] = [complement.meta[key]];
    }
  }
  return main;
}

function convert2D(files, options) {
  let temp, temp2, result;
  if (files.proc2s && files.procs) {
    result = parseData(files.procs, options);
    temp = parseData(files.proc2s, options);
    result = mergeMetadata(result, temp);
  }

  temp = parseData(files.acqus, options);
  temp2 = parseData(files.acqu2s, options);

  temp = mergeMetadata(temp, temp2);

  if (!result) {
    result = temp;
  }
  for (let key in temp.meta) {
    if (result.meta[key] === undefined) {
      result.meta[key] = temp.meta[key];
    }
  }

  for (let key in result.meta) {
    if (!Array.isArray(result.meta[key])) {
      result.meta[key] = [result.meta[key]];
    }
  }

  result.meta.nbSubSpectra = files['2rr']
    ? parseInt(result.meta.SI[1], 10)
    : parseInt(result.meta.TD[1], 10);

  if (!result.meta.SW_p) {
    // eslint-disable-next-line camelcase
    result.meta.SW_p = result.meta.SW_h;
  }
  if (!result.meta.SF) {
    result.meta.SF = result.meta.SFO1;
  }

  let firstY, lastY, xOffset, yOffset;
  if (files['2rr']) {
    let sf = parseFloat(result.meta.SF[1]);
    let swP = parseFloat(result.meta.SW_p[1] || result.meta.SW[1]);
    yOffset = parseFloat(result.meta.OFFSET[1]);
    xOffset = parseFloat(result.meta.OFFSET[0]);
    firstY = yOffset;
    lastY = yOffset - swP / sf;
    result.meta.firstY = firstY;
    result.meta.lastY = lastY;
    setXYSpectrumData(files['2rr'], result, true);
  } else if (files.ser) {
    firstY = 0;
    lastY = result.meta.nbSubSpectra;
    let xWindowSize = parseFloat(result.meta.SW[0]);
    let yWindowSize = parseFloat(result.meta.SW[1]);
    let xTransmitterFrequency = parseFloat(result.meta.SFO1[0]);
    let yTransmitterFrequency = parseFloat(result.meta.SFO1[1]);
    let xTransmitterFrequencyOffset = parseFloat(result.meta.O1[0]);
    let yTransmitterFrequencyOffset = parseFloat(result.meta.O1[1]);
    xOffset =
      xTransmitterFrequencyOffset / xTransmitterFrequency + xWindowSize / 2;
    yOffset =
      yTransmitterFrequencyOffset / yTransmitterFrequency + yWindowSize / 2;
    setFIDSpectrumData(files.ser, result);
  }

  let pageValue = firstY;
  let nbSubSpectra = result.meta.nbSubSpectra;
  let deltaY = (lastY - firstY) / (nbSubSpectra - 1);
  for (let i = 0; i < nbSubSpectra; i++) {
    pageValue += deltaY;
    result.spectra[i].pageValue = pageValue;
  }
  let { NUC1: nuc1, AXNUC: axnuc, SF: sf } = result.meta;
  const nucleus = axnuc ? axnuc : nuc1 ? nuc1 : [];
  result.info['2D_Y_NUCLEUS'] = nucleus[1];
  result.info['2D_X_NUCLEUS'] = nucleus[0];
  result.info['2D_Y_FRECUENCY'] = sf[1];
  result.info['2D_X_FRECUENCY'] = sf[0];
  result.info['2D_Y_OFFSET'] = yOffset;
  result.info['2D_X_OFFSET'] = xOffset;
  result.info.twoD = result.twoD = true;

  return result;
}

/**
 * Extract information and data from bruker files.
 * @param {object} brukerFiles - Needed bruker files to parse raw data.
 * @param {object} [options = {}] - options.
 * @param {boolean} [options.xy] - if true, spectra data is a object with x and y
 * @param {RegExp} [options.keepRecordsRegExp='\/.*\/'] - regular expresion to parse the metadata of the spectrum.
 * @param {boolean} [options.noContours=false] - if true the contour data is not generated.
 * @returns
 */

function convertFolder(brukerFiles, options = {}) {
  let start = new Date();
  let result;
  if (brukerFiles.ser || brukerFiles['2rr']) {
    result = convert2D(brukerFiles, options);
  } else if (brukerFiles['1r'] || brukerFiles['1i'] || brukerFiles.fid) {
    result = convert1D(brukerFiles, options);
  } else {
    throw new RangeError('The current files are invalid');
  }
  //normalizing info
  result.meta.DATE = parseFloat(result.meta.DATE);
  if (result.meta.GRPDLY) {
    result.meta.GRPDLY = parseFloat(result.meta.GRPDLY);
    result.meta.DSPFVS = parseFloat(result.meta.DSPFVS);
    result.meta.DECIM = parseFloat(result.meta.DECIM);
  }

  for (let key in result.meta) {
    if (!Array.isArray(result.meta[key])) {
      continue;
    }
    if (result.meta[key].length === 1) {
      result.meta[key] = result.meta[key][0];
    } else if (
      typeof result.meta[key][0] === 'string' &&
      result.meta[key][0].indexOf('(0..') > -1
    ) {
      result.meta[key] = result.meta[key][0];
    }
  }

  if (result.twoD) {
    add2D(result, options);
    if (result.profiling) {
      result.profiling.push({
        action: 'Finished countour plot calculation',
        time: new Date() - start,
      });
    }
    if (!options.keepSpectra) {
      delete result.spectra;
    }
  }

  let spectra = result.spectra;

  if (options.xy && !!spectra) {
    //the spectraData should not be a oneD Array but an object with x and y
    if (spectra.length > 0) {
      for (let i = 0; i < spectra.length; i++) {
        let spectrum = spectra[i];
        if (spectrum.data.length) {
          let data = spectrum.data;
          let newData = {
            x: new Float64Array(data.length / 2),
            y: new Float64Array(data.length / 2),
          };
          for (let k = 0; k < data.length; k = k + 2) {
            newData.x[k / 2] = data[k];
            newData.y[k / 2] = data[k + 1];
          }
          spectrum.data = newData;
        }
      }
    }
  }
  const { file } = brukerFiles;
  if (file) {
    result.source = { file };
  }

  return result;
}

function extractFilePaths(pathSpectrum, options = {}) {
  let { zipFiles } = options;

  const expnoCheck = pathSpectrum.replace(
    /([.*\w+/]*)([0-9]+\/)[pdata|fid|ser]\/*.*/,
    '$1$2',
  );

  const procnoCheck = pathSpectrum.match('pdata')
    ? pathSpectrum.replace(/([.*\w+/]*[0-9]+\/pdata\/[0-9]+\/)*.*/, '$1')
    : false;
  let filePaths = [];
  for (let file in zipFiles) {
    if (file.endsWith('/')) continue;
    let parts = file.split('/');
    let expno =
      parts.indexOf('pdata') > 0
        ? file.slice(0, file.indexOf('pdata'))
        : parts[parts.length - 2].match(/^[0-9]+$/)
        ? file.slice(0, file.lastIndexOf('/') + 1)
        : null;

    if (expnoCheck !== expno) continue;

    if (file.match('pdata')) {
      let procno = file.slice(0, file.lastIndexOf('/') + 1);
      if (!procnoCheck) {
        if (file.match(/[1|2]+[i|r]+[i|r]*/)) continue;
      } else if (procnoCheck !== procno) {
        continue;
      }
    }

    filePaths.push(file);
  }
  return filePaths;
}

async function extractSingleSpectrumZip(pathSpectrum, options = {}) {
  let { zipFiles } = options;

  const filePaths = extractFilePaths(pathSpectrum, { zipFiles });
  let zipFolder = new JSZip__default['default']();
  for (let file of filePaths) {
    zipFolder.file(file, await zipFiles[file].async('arraybuffer'));
  }

  return {
    extension: 'zip',
    name: pathSpectrum,
    binary: await zipFolder.generateAsync({
      type: 'uint8array',
      compression: 'DEFLATE',
      compressionOptions: { level: 9 },
    }),
  };
}

const BINARY = 1;
const TEXT = 2;

/**
 * Load a zip file using jszip and looking for folders contaning bruker files to parse.
 * @param {*} zipFile - binary or base64 file of the bruker zip file.
 * @param {object} [options={}] - options for jszip and convertFolder functions.
 * @param {boolean} [options.keepOriginal=false] - options to keep a smaller zip file per spectrum.
 * @returns {Promise} - Array of spectrum parsed from fid, ser, 2rr, 1r bruker files.
 */
function convertZip(zipFile, options = {}) {
  const { keepOriginal = false } = options;
  const jsZip = new JSZip__default['default']();

  return jsZip.loadAsync(zipFile, options).then((zip) => {
    let files = {
      ser: BINARY,
      fid: BINARY,
      acqus: TEXT,
      acqu2s: TEXT,
      procs: TEXT,
      proc2s: TEXT,
      '1r': BINARY,
      '1i': BINARY,
      '2rr': BINARY,
    };
    let folders = zip.filter(function (relativePath) {
      if (relativePath.match('__MACOSX')) return false;
      if (
        relativePath.endsWith('ser') ||
        relativePath.endsWith('fid') ||
        relativePath.endsWith('1r') ||
        relativePath.endsWith('2rr')
      ) {
        return true;
      }
      return false;
    });

    let spectra = new Array(folders.length);

    for (let i = 0; i < folders.length; ++i) {
      let promises = [];
      let name = folders[i].name;
      name = name.substr(0, name.lastIndexOf('/') + 1);
      promises.push(name);
      let currFolder = zip.folder(name);
      let currFiles = currFolder.filter(function (relativePath) {
        return files[relativePath] ? true : false;
      });
      if (name.indexOf('pdata') >= 0) {
        promises.push('acqus');
        promises.push(
          zip.file(name.replace(/pdata\/[0-9]+\//, 'acqus')).async('string'),
        );
        let acqu2s = zip.file(name.replace(/pdata\/[0-9]+\//, 'acqu2s'));
        if (acqu2s) {
          promises.push('acqu2s');
          promises.push(acqu2s.async('string'));
        }
      }
      for (let j = 0; j < currFiles.length; ++j) {
        let idx = currFiles[j].name.lastIndexOf('/');
        name = currFiles[j].name.substr(idx + 1);
        promises.push(name);
        if (files[name] === BINARY) {
          promises.push(currFiles[j].async('arraybuffer'));
        } else {
          promises.push(currFiles[j].async('string'));
        }
      }
      if (keepOriginal) {
        promises.push('file');
        promises.push(
          extractSingleSpectrumZip(folders[i].name, { zipFiles: zip.files }),
        );
      }
      spectra[i] = Promise.all(promises).then((result) => {
        let brukerFiles = {};
        for (let k = 1; k < result.length; k += 2) {
          name = result[k];
          brukerFiles[name] = result[k + 1];
        }

        return {
          filename: result[0],
          value: convertFolder(brukerFiles, options),
        };
      });
    }
    return Promise.all(spectra);
  });
}

exports.convertFolder = convertFolder;
exports.convertZip = convertZip;
