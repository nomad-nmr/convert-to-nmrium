'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var iobuffer = require('iobuffer');

const endianness = {
  0: 'bigEndian',
  1: 'littleEndian',
};

const instrumentTable = {
  0: 'NONE',
  1: 'GSX',
  2: 'ALPHA',
  3: 'ECLIPSE',
  4: 'MASS_SPEC',
  5: 'COMPILER',
  6: 'OTHER_NMR',
  7: 'UNKNOWN',
  8: 'GEMINI',
  9: 'UNITY',
  10: 'ASPECT',
  11: 'UX',
  12: 'FELIX',
  13: 'LAMBDA',
  14: 'GE_1280',
  15: 'GE_OMEGA',
  16: 'CHEMAGNETICS',
  17: 'CDFF',
  18: 'GALACTIC',
  19: 'TRIAD',
  20: 'GENERIC_NMR',
  21: 'GAMMA',
  22: 'JCAMP_DX',
  23: 'AMX',
  24: 'DMX',
  25: 'ECA',
  26: 'ALICE',
  27: 'NMR_PIPE',
  28: 'SIMPSON',
};

const dataTypeTable = {
  0: '64Bit Float',
  1: '32Bit Float',
  2: 'Reserved',
  3: 'Reserved',
};

const dataFormatTable = {
  1: 'One_D',
  2: 'Two_D',
  3: 'Three_D',
  4: 'Four_D',
  5: 'Five_D',
  6: 'Six_D',
  7: 'Seven_D',
  8: 'Eight_D',
  9: 'not for NMR data formats',
  10: 'not for NMR data formats',
  11: 'not for NMR data formats',
  12: 'Small_Two_D',
  13: 'Small_Three_D',
  14: 'Small_Four_D',
};

const dataAxisTypeTable = {
  0: 'None', //Axis is not used.
  1: 'Real', //Axis has real data only, no imaginary.
  2: 'TPPI',
  3: 'Complex',
  4: 'Real_Complex',
  /* Axis should be accessed as complex when it is the major axis,
            accessed as real otherwise.  This is only valid when all axes in
            use have this setting.*/
  5: 'Envelope',
  /* Behaves the same way as a Real_Complex dimension but the data
        has different meaning.  Instead of being treated as real and
        imaginary parts of a complex number, the data should be treated as minimum and maximum parts of a projection.  This is used
        for the data that results from an envelope projection.*/
};

const prefixTable = {
  '-8': 'Yotta',
  '-6': 'Exa',
  '-7': 'Zetta',
  '-5': 'Pecta',
  '-4': 'Tera',
  '-3': 'Giga',
  '-2': 'Mega',
  '-1': 'Kilo',
  0: 'None',
  1: 'Milli',
  2: 'Micro',
  3: 'Nano',
  4: 'Pico',
  5: 'Femto',
  6: 'Atto',
  7: 'Zepto',
};

const unitPrefixTable = {
  Yotta: 24,
  Exa: 21,
  Zetta: 18,
  Pecta: 15,
  Tera: 12,
  Giga: 9,
  Mega: 6,
  Kilo: 3,
  None: 0,
  Milli: -3,
  Micro: -6,
  Nano: -9,
  Pico: -12,
  Femto: -15,
  Atto: -18,
  Zepto: -21,
};

const baseTable = {
  0: 'None',
  1: 'Abundance',
  2: 'Ampere',
  3: 'Candela',
  4: 'Celsius',
  5: 'Coulomb',
  6: 'Degree',
  7: 'Electronvolt',
  8: 'Farad',
  9: 'Sievert',
  10: 'Gram',
  11: 'Gray',
  12: 'Henry',
  13: 'Hertz',
  14: 'Kelvin',
  15: 'Joule',
  16: 'Liter',
  17: 'Lumen',
  18: 'Lux',
  19: 'Meter',
  20: 'Mole',
  21: 'Newton',
  22: 'Ohm',
  23: 'Pascal',
  24: 'Percent',
  25: 'Point',
  26: 'Ppm',
  27: 'Radian',
  28: 'Second',
  29: 'Siemens',
  30: 'Steradian',
  31: 'Tesla',
  32: 'Volt',
  33: 'Watt',
  34: 'Weber',
  35: 'Decibel',
  36: 'Dalton',
  37: 'Thompson',
  38: 'Ugeneric', // Treated as None, but never displayed',
  39: 'LPercent ', // Treated as percent for display, but different for comparison',
  40: 'PPT', // Parts per trillion (Private, do not use)',
  41: 'PPB ', // Parts per billion (Private, do not use)',
  42: 'Index',
};

const dataAxisRangedTable = {
  0: 'Ranged',
  /* The ruler for the axis ranges from Data_Axis_Start[n] to
        Data_Axis_Stop[n] with a step function of
            (Data_Axis_Stop[n] - Data_Axis_Start[n]) /
            (Data_Offset_Stop[n] - Data_Offset_Start[n]) */
  1: 'Listed', // (deprecated)
  /* The ruler for the axis is a list of doubles stored in the
        List Section.  Values in the ruler may be anything.*/
  2: 'Sparse',
  /*The ruler for the axis is a list of doubles stored in the
        List Section.  Values in the rulers must be strictly monotonically
        increasing or decreasing.*/
  3: 'Listed',
  /* The ruler for the axis is a list of doubles stored in the
        List Section.  Values in the rulers do not fit definition of Sparse.*/
};

const valueTypeTable = {
  0: 'String',
  1: 'Integer',
  2: 'Float',
  3: 'Complex',
  4: 'Infinity',
};

function getPar(param, searchStr) {
  return param.paramArray.find((o) => o.name === searchStr) || '';
}

function getDigitalFilter(param) {
  const orders = param.paramArray.find((e) => e.name === 'orders');
  const factors = param.paramArray.find((e) => e.name === 'factors');
  const sweep = param.paramArray.find((e) => e.name === 'x_sweep');
  const acqTime = param.paramArray.find((e) => e.name === 'x_acq_time');
  const nbPoints = param.paramArray.find((e) => e.name === 'x_points');

  const shouldStop = [orders, factors, sweep, acqTime, nbPoints].some((e) => e === undefined);

  if (shouldStop) {
    return;
  }

  const s = parseInt(orders.value.slice(0, 1), 10);
  const jump = orders.value.slice(1).length / s;

  let arg = 0;
  let factorNumber = new Int8Array(s);
  let offsetO = 1;
  let offsetF = 0;
  for (let i = 0; i < s; i++) {
    factorNumber[i] = parseInt(factors.value.slice(offsetF, offsetF + 1), 10);
    offsetF += 1;
  }

  for (let i = 0; i < s; i++) {
    let productorial = 1;
    for (let j = i; j < s; j++) {
      productorial *= factorNumber[j];
    }
    arg +=
      (parseInt(orders.value.slice(offsetO, offsetO + jump), 10) - 1) /
      productorial;
    offsetO += jump;
  }
  arg /= 2;

  const delaySec = arg / sweep.value;
  return (delaySec / acqTime.value) * (nbPoints.value - 1);
}

function getMagnitude(param, searchStr) {
  let par = getPar(param, searchStr) || 'NA';
  if (par === 'NA') {
    return { magnitude: 'NA', unit: 'NA' };
  }
  let unit = par.unit[0].base;
  let unitMult = unitPrefixTable[par.unit[0].prefix];
  let magnitude = par.value * 10 ** unitMult;
  return { magnitude, unit };
}

function getUnit(buffer, size) {
  let unit = [];
  for (let i = 0; i < size; i++) {
    let byte = buffer.readByte();
    let prefix = prefixTable[byte >> 4];
    let power = byte & 0b00001111;
    let base = baseTable[buffer.readInt8()];
    unit.push({ prefix, power, base });
  }
  return unit;
}

function getString(buffer, size) {
  let string = [];
  for (let i = 0; i < size; i++) {
    let char = buffer.readChar();
    if (char !== '\u0000') {
      string.push(char);
    }
  }
  return string.join('');
}

function getParamName(buffer, size) {
  let string = [];
  for (let i = 0; i < size; i++) {
    let char = buffer.readChar();
    if (char !== ' ') {
      string.push(char);
    }
  }
  return string.join('');
}

function getArray(buffer, size, format) {
  let double = [];
  for (let i = 0; i < size; i++) {
    switch (format) {
      case 'readUint32':
        double.push(buffer.readUint32());
        break;
      case 'readFloat64':
        double.push(buffer.readFloat64());
        break;
      case 'readFloat32':
        double.push(buffer.readFloat32());
        break;
      case 'readUint8':
        double.push(buffer.readUint8());
        break;
      case 'readBoolean':
        double.push(buffer.readBoolean());
        break;
    }
  }
  return double;
}

/**
 * A parser for 1D and 2D JDL NMR Files
 * @param {ArrayBuffer} buffer - a buffer object containing the JDL file
 * @return {Object} - an Object with converted data
 */
function parseJEOL(buffer) {
  let ioBuffer = new iobuffer.IOBuffer(buffer);
  ioBuffer.setBigEndian();

  // read header section
  let byte;
  let header = {};
  let byteArray = [];

  header.fileIdentifier = ioBuffer.readChars(8);
  header.endian = endianness[ioBuffer.readInt8()];
  header.majorVersion = ioBuffer.readUint8();
  header.minorVersion = ioBuffer.readUint16();
  header.dataDimensionNumber = ioBuffer.readUint8();

  header.dataDimensionExist = ioBuffer
    .readByte()
    .toString(2)
    .split('')
    .map((x) => Boolean(Number(x)));

  byte = ioBuffer.readByte();
  header.dataType = dataTypeTable[byte >> 6];
  header.dataFormat = dataFormatTable[byte & 0b00111111];
  header.dataInstrument = instrumentTable[ioBuffer.readInt8()];
  header.translate = getArray(ioBuffer, 8, 'readUint8');
  header.dataAxisType = getArray(ioBuffer, 8, 'readUint8').map(
    (x) => dataAxisTypeTable[x],
  );

  header.dataUnits = getUnit(ioBuffer, 8);
  header.title = getString(ioBuffer, 124);

  for (byte in getArray(ioBuffer, 4, 'readUint8')) {
    byteArray.push(dataAxisRangedTable[byte >> 4]);
    byteArray.push(dataAxisRangedTable[byte & 0b00001111]);
  }

  header.dataAxisRanged = byteArray;
  header.dataPoints = getArray(ioBuffer, 8, 'readUint32');
  header.dataOffsetStart = getArray(ioBuffer, 8, 'readUint32');
  header.dataOffsetStop = getArray(ioBuffer, 8, 'readUint32');
  header.dataAxisStart = getArray(ioBuffer, 8, 'readFloat64');
  header.dataAxisStop = getArray(ioBuffer, 8, 'readFloat64');

  byteArray = new Uint8Array(4);
  for (let i = 0; i < 4; i++) {
    byteArray[i] = ioBuffer.readByte();
  }
  let year = 1990 + (byteArray[0] >> 1);
  let month = ((byteArray[0] << 3) & 0b00001000) + (byteArray[1] >> 5);
  let day = byteArray[2] & 0b00011111;
  header.creationTime = { year, month, day };

  for (let i = 0; i < 4; i++) {
    byteArray[i] = ioBuffer.readByte();
  }
  year = 1990 + (byteArray[0] >> 1);
  month = ((byteArray[0] << 3) & 0b00001000) + (byteArray[1] >> 5);
  day = byteArray[2] & 0b00011111;
  header.revisionTime = { year, month, day };

  header.nodeName = getString(ioBuffer, 16);
  header.site = getString(ioBuffer, 128);
  header.author = getString(ioBuffer, 128);
  header.comment = getString(ioBuffer, 128);

  let dataAxisTitles = [];
  for (let i = 0; i < 8; i++) {
    dataAxisTitles.push(getString(ioBuffer, 32));
  }
  header.dataAxisTitles = dataAxisTitles;

  header.baseFreq = getArray(ioBuffer, 8, 'readFloat64');
  header.zeroPoint = getArray(ioBuffer, 8, 'readFloat64');
  header.reversed = getArray(ioBuffer, 8, 'readBoolean');
  ioBuffer.skip(3);
  header.annotationOK = Boolean(ioBuffer.readByte() >> 7);
  header.historyUsed = ioBuffer.readUint32();
  header.historyLength = ioBuffer.readUint32();
  header.paramStart = ioBuffer.readUint32();
  header.paramLength = ioBuffer.readUint32();
  header.ListStart = getArray(ioBuffer, 8, 'readUint32');
  header.ListLength = getArray(ioBuffer, 8, 'readUint32');
  header.dataStart = ioBuffer.readUint32();
  header.dataLength = (ioBuffer.readUint32() << 32) | ioBuffer.readUint32();
  header.contextStart = (ioBuffer.readUint32() << 32) | ioBuffer.readUint32();
  header.contextLength = ioBuffer.readUint32();
  header.annoteStart = (ioBuffer.readUint32() << 32) | ioBuffer.readUint32();
  header.annoteLength = ioBuffer.readUint32();
  header.totalSize = (ioBuffer.readUint32() << 32) | ioBuffer.readUint32();
  header.unitLocation = getArray(ioBuffer, 8, 'readUint8');

  let compoundUnit = [];
  for (let i = 0; i < 2; i++) {
    let unit = [];
    let scaler = ioBuffer.readInt16();
    for (let j = 0; j < 5; j++) {
      byte = ioBuffer.readInt16();
      unit.push(byte);
    }
    compoundUnit.push({ scaler, unit });
  }
  header.compoundUnit = compoundUnit;

  // section parameters (param header and array)
  if (header.endian === 'littleEndian') {
    ioBuffer.setLittleEndian();
  }
  ioBuffer.seek(header.paramStart);

  let parameters = {
    parameterSize: ioBuffer.readUint32(),
    lowIndex: ioBuffer.readUint32(),
    highIndex: ioBuffer.readUint32(),
    totalSize: ioBuffer.readUint32(),
  };
  let paramArray = [];
  for (let p = 0; p < parameters.highIndex + 1; p++) {
    ioBuffer.skip(4);
    let scaler = ioBuffer.readInt16();
    let unit = getUnit(ioBuffer, 5);
    ioBuffer.skip(16);
    let valueType = valueTypeTable[ioBuffer.readInt32()];
    ioBuffer.seek(ioBuffer.offset - 20);
    let value;
    switch (valueType) {
      case 'String':
        value = getParamName(ioBuffer, 16);
        break;
      case 'Integer':
        value = ioBuffer.readInt32();
        ioBuffer.skip(12);
        break;
      case 'Float':
        value = ioBuffer.readFloat64();
        ioBuffer.skip(8);
        break;
      case 'Complex':
        value.Real = ioBuffer.readFloat64();
        value.Imag = ioBuffer.readFloat64();
        break;
      case 'Infinity':
        value = ioBuffer.readInt32();
        ioBuffer.skip(12);
        break;
      default:
        ioBuffer.skip(16);
        break;
    }
    ioBuffer.skip(4);
    let name = getParamName(ioBuffer, 28);
    paramArray.push({ name: name.toLowerCase(), scaler, unit, value, valueType });
  }
  parameters.paramArray = paramArray;

  // data section
  ioBuffer.seek(header.dataStart);
  if (header.endian === 'littleEndian') {
    ioBuffer.setLittleEndian();
  }

  let data = {};
  let dataSectionCount = 1;
  let realComplex = 0;
  for (let type of header.dataAxisType) {
    if (type === 'Real_Complex' && realComplex === 0) {
      dataSectionCount += 1;
      realComplex += 1;
    }
    if (type === 'Complex') {
      dataSectionCount *= 2;
    }
  }

  if (header.dataFormat !== 'One_D' && header.dataFormat !== 'Two_D') {
    throw new Error('Only One_D and two_D data formats are implemented yet');
  }

  if (header.dataFormat === 'One_D') {
    for (let s = 0; s < dataSectionCount; s++) {
      let section;
      if (header.dataType === '32Bit Float') {
        section = getArray(ioBuffer, header.dataPoints[0], 'readFloat32');
      } else if (header.dataType === '64Bit Float') {
        section = getArray(ioBuffer, header.dataPoints[0], 'readFloat64');
      }
      if (s === 0) data.re = section;
      if (s === 1) data.im = section;
    }
  }

  if (header.dataFormat === 'Two_D') {
    let me = 32;
    let dim1 = header.dataPoints[0];
    let dim2 = header.dataPoints[1];
    // console.log(
    // `dim1: ${dim1},
    // dim2: ${dim2},
    // total: ${dim1 * dim2},
    // total(byte): ${dim1 * dim2 * 8},
    // total(length): ${dim1 * dim2 * 8 * dataSectionCount}
    // m size: ${dim1 / me} / ${dim2 / me}`,
    // );
    let I = dim2 / me;
    let J = dim1 / me;

    for (let s = 0; s < dataSectionCount; s++) {
      let section;
      for (let i = 0; i < I; i++) {
        let row = [];
        for (let j = 0; j < J; j++) {
          for (let k = 0; k < me; k++) {
            if (j === 0) {
              if (header.dataType === '32Bit Float') {
                row[k] = getArray(ioBuffer, me, 'readFloat32');
              } else if (header.dataType === '64Bit Float') {
                row[k] = getArray(ioBuffer, me, 'readFloat64');
              }
            } else {
              if (header.dataType === '32Bit Float') {
                row[k] = row[k].concat(getArray(ioBuffer, me, 'readFloat32'));
              } else if (header.dataType === '64Bit Float') {
                row[k] = row[k].concat(getArray(ioBuffer, me, 'readFloat64'));
              }
            }
          }
        }
        if (i === 0) {
          section = row;
        } else {
          section = section.concat(row);
        }
      }
      if (dataSectionCount === 2) {
        if (s === 0) data.re = section;
        if (s === 1) data.im = section;
      }
      if (dataSectionCount === 4) {
        if (s === 0) {
          data.re = {};
          data.re.re = section;
        }
        if (s === 1) data.re.im = section;
        if (s === 2) {
          data.im = {};
          data.im.re = section;
        }
        if (s === 3) data.im.im = section;
      }
    }
  }
  // format output
  let nucleus = [];
  let acquisitionTime = [];
  let spectralWidth = [];
  let spectralWidthClipped = [];
  let resolution = [];
  let originFrequency = [];
  let frequencyOffset = [];
  let dataUnits = [];
  if (header.dataFormat === 'One_D' || header.dataFormat === 'Two_D') {
    nucleus.push(getPar(parameters, 'x_domain').value);
    acquisitionTime.push(getMagnitude(parameters, 'x_acq_time'));
    spectralWidth.push(getMagnitude(parameters, 'x_sweep'));
    spectralWidthClipped.push(getMagnitude(parameters, 'x_sweep_clipped'));
    resolution.push(getMagnitude(parameters, 'x_resolution'));
    originFrequency.push(getMagnitude(parameters, 'x_freq'));
    frequencyOffset.push(getMagnitude(parameters, 'x_offset'));
    dataUnits.push(header.dataUnits[0].base);
  }
  if (header.dataFormat === 'Two_D') {
    nucleus.push(getPar(parameters, 'y_domain').value);
    acquisitionTime.push(getMagnitude(parameters, 'y_acq_time'));
    spectralWidth.push(getMagnitude(parameters, 'y_sweep'));
    resolution.push(getMagnitude(parameters, 'y_resolution'));
    originFrequency.push(getMagnitude(parameters, 'y_freq'));
    frequencyOffset.push(getMagnitude(parameters, 'y_offset'));
    dataUnits.push(header.dataUnits[1].base);
  }

  let digest = {
    info: {
      sampleName: getPar(parameters, 'sample_id').value,
      creationTime: header.creationTime,
      revisionTime: header.revisionTime,
      author: header.author,
      comment: header.comment,
      solvent: getPar(parameters, 'solvent').value,
      temperature: getMagnitude(parameters, 'temp_get'),
      probeName: getPar(parameters, 'probe_id').value,
      fieldStrength: getMagnitude(parameters, 'field_strength'),
      experiment: getPar(parameters, 'experiment').value,
      dimension: header.dataDimensionNumber,
      nucleus,
      pulseStrength90: getMagnitude(parameters, 'x90'),
      numberOfScans: getPar(parameters, 'scans').value,
      relaxationTime: getMagnitude(parameters, 'relaxation_delay'),
      dataPoints: header.dataPoints.slice(0, header.dataDimensionNumber),
      dataOffsetStart: header.dataOffsetStart,
      dataOffsetStop: header.dataOffsetStop,
      dataUnits: dataUnits,
      dataSections: Object.keys(data),
      originFrequency,
      frequencyOffset,
      acquisitionTime,
      spectralWidth,
      spectralWidthClipped,
      dataAxisStart: header.dataAxisStart,
      dataAxisStop: header.dataAxisStop,
      resolution: resolution,
      decimationRate: getPar(parameters, 'decimation_rate').value,
      paramList: JSON.stringify(parameters.paramArray.map((par) => par.name)),
    },

    headers: header,
    parameters: parameters,
    data: data,
  };

  digest.info.digitalFilter = getDigitalFilter(parameters);

  return digest;
}

exports.parseJEOL = parseJEOL;
